
\chapter{Implementation and Evaluation}
\label{chap:implementation}

In Section \ref{sec:challenges} we presented the three main challenges of this research paper: portability, speed and security. To accurately assess whether the design presented in Chapter \ref{chap:solution} meets these challenges, an example system was implemented by the researchers of this paper. The first part of chapter is devoted to illustrating the various aspects of this implementation. In the second part of this chapter, this implementation is evaluated and analysed with regard to the challenges proposed earlier. 

\section{Implementation}
\label{sec:implementation}

The structure of this section is as follows: First, the individual pieces of hardware that were used in the implementation are discussed. Second, the set-up of the demo in general is explained. In the last section of this chapter, the implementations of the three key aspects of Section \ref{sec:obd2_access_control} are illustrated (authenticated key agreement procedure, message authentication procedure and permissions table).

\subsection{Hardware}
\label{sec:hardware}
It is clear that the design presented in Chapter \ref{chap:solution}, as well as the OBD-II system is general, is of an embedded nature. The gateway ECU is embedded by default, since it is implemented by a microcontroller in all extant intra vehicle networks. The tester device however, introduced by the researchers of this paper, could be either implemented by an embedded device (e.g. tester), or a software application running on a standard PC (e.g. a laptop owned by the repair shop), that is connected to the OBD-II port via some adapter. The decision was made to implement the former (i.e. the tester is also embedded). Because of this decision, the tester and gateway can be implemented on the same microcontroller architecture. This also means that the same CAN messaging library can be used in both microcontrollers.\\ \\ The goal of this implementation is to serve as a proof of the practical feasibility of our proposed solution. This is why the choice of hardware architecture is very important. The idea is that if an implementation on a resource constrained microcontroller, would meet our challenges (i.e. portability, security and speed); This would prove that implementation is possible on all microcontrollers that feature better specifications than the one we used in our demo. This is why we chose to select a microcontroller architecture that is as limited as possible.  \\ \\ The microcontroller chosen for our implementation is the Atmel AT90CAN128. Which has a word size of 8 bits, boasts a 128 KB flash memory, 4KB of EEPROM and 4KB SRAM (for more information on these specifications see  Section \ref{sec:microcontrollers}). The CPU of this microcontroller was run at a clock speed of 8 MHz. More importantly, it includes a dedicated CAN controller, which allows for easy CAN networking between devices. The DVK90CAN1 is a development kit that includes the AT90CAN128, as well as introducing a series of hardware peripherals like power supply inputs, LEDS, buttons, connectors, transceivers, programming interfaces, debuggers, etc. The ones that were extensively used in our implementation are:
\begin{itemize}
	\item \textbf{Programming/Debugging interface:} The DVK90CAN1 includes the option of easily connecting to a standard PC for programming and debugging. This is done by connecting the ATMEL-ICE BASIC programmer to both the DVK90CAN1 board and a PC running Atmel Studio, which is an integrated development platform (IDP) that allows us to run and debug C and assembly code on both microcontrollers.
	
	\item \textbf{CAN transceiver:} This device functions as a transmitter and receiver by transmitting messages from the CAN controller on to the CAN bus (male DB9), as well as receiving incoming CAN messages and forwarding them to the CAN controller; effectively implementing the physical layer of CAN.
	
	\item \textbf{Male DB9 connector:} This connector belongs to the D-sub series, where the B denotes the shell size and the 9 means there are 9 pins. This connector assumes the CAN bus connections.
	
	\item \textbf{RS-232 driver/receiver:} Recommended standard 232 (RS-232) is a standard for serial transmission of data. The driver/receiver is responsible for transmitting and receiving RS-232 data (female DB-9).
	
	\item \textbf{Female DB9 connector:} This connector assumes the RS-232 connections.
	
	\item \textbf{Compass Card Keyboard} 4 de-centered push-buttons of compass card keyboard are present on the board, allowing for user interactivity.
\end{itemize}
Besides some peripherals offered by the DVK90CAN1 board and the ATMEL-ICE BASIC programmer, two more pieces of hardware were use in our system. First, there's a female-to-female DB9 cable. This is used to connect the CAN interfaces of both boards. Second there's a male-to-male DB9 cable that is connected to a generic RS232 to USB converter. This cable allows both boards to be connected to a PC for serial communications.

\subsection{Demo Set-Up}
\label{sec:demo_setup}

Figure \ref{fig:demo} shows the set-up of our implementation. One board functions as the tester (the one on the left), which is connected via CAN (using the female-to-female DB9 cable) to the other board (the one in the middle), which in turn functions as the gateway. This connection is used to implement the general authenticated key agreement and message authentication procedures presented in Section \ref{subsec:authenticated_key_agreement_procedure} and \ref{subsec:message_authentication_procedure}. The permission table outlined in Section \ref{subsec:sol_permissions_table} is implemented on the gateway. The gateway is also connected to a PC using the RS-232 communications standard, to allow for real time feedback (e.g. signalling when a signature verification procedure successfully terminates). The attentive reader might notice two integral components missing from this set-up: the central server that is introduced in Section \ref{fig:authentication_procedure}, as well as the intra vehicle network itself. The decision was made to implement these components only logically. This was done for two reasons: first, a realistic implementation of these components would result in the introduction of more hardware, greatly increasing the time and cost required to construct a working demo. Second, since the primary focus of this paper is the RBAC system proposed in Chapter \ref{chap:solution}, as well as all the procedures and systems introduced to enforce it on the gateway (i.e. authenticated key agreement procedure, message authentication procedure and permissions table); providing a physical central server and intra vehicle network implementation can be considered out of scope. The logical implementation of both these components was done as follows:
\begin{itemize}
	\item \textbf{Central Server:} The software on the tester board implements a dedicated key-API that specifies a series of private key related functions (for signing and calculating the shared secret). As far as the main tester software is concerned, calling these functions could result in a remote server being addressed.
	
	\item \textbf{Intra Vehicle Network:} The RS-232 connection between gateway and PC is used for this purpose. Whenever a message is accepted by the gateway, instead of forwarding the message to another sub-network, a message is transmitted to the PC. This message contains the ID of the accepted message, as well as a line of text signalling that the message was accepted.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{demo_setup.jpg}
	\caption{Hardware set-up that is used to implement the proposed solution.}
	\label{fig:demo}
\end{figure}

\subsection{OBD-II Access Control Implementation}
The key aspects aspects of the OBD-II access control system presented in Chapter \ref{chap:solution} are the authenticated key agreement procedure, the message authentication procedure and of course the permissions table. How these were implemented in the set-up presented in Section \ref{sec:demo_setup} is discussed next. The source code of our implementation can be found in \cite{Michel}.  

\subsubsection{Authenticated Key Agreement Procedure Implementation}
\label{subsec:authenticated_key_agreement_procedure_implementation}

Figure \ref{fig:authentication_procedure_implementation} shows how the authentication procedure was implemented in our demo. Because of our decision to omit the central server and the intra vehicle network, these are naturally not included in the diagram. Because of this, the tester now stores the OBD-II private key $P_{obd}$ instead of the central server. In our diagram we have chosen to include the size of this key (in bits) in the superscript: $Pr_{obd}^{256}$. This was repeated for every piece of data in the diagram (e.g. keys and signatures). The corresponding public key $Pb_{obd}^{512}$ is stored on the gateway. The size of these keys was mandated by the decision to guarantee a security level of 128 bits (see Section \ref{sec:security_level}). As mentioned in Section \ref{subsec:ECC}, the decision was made to use elliptic curve asymmetric key pairs. The TinyECC\footnote{\url{https://github.com/kmackay/micro-ecc}} C library offers a safe and efficient implementation for ECC operations on AVR microcontrollers. According to \cite{Siddiqui}, ECC keys have the property that the size of the underlying field (i.e. the size of the private key), should be twice the security parameter \cite{Siddiqui}. The decision was made to work with the secp256r1 curve (also supported by TinyECC), which meets our security level guarantee ($\frac{256}{2}=128$) and introduces fixed sizes for our keys (256 bit for the private key and 512 bits for the public key).

\paragraph{The Procedure}

The authentication procedure is initiated by the tester, which transmits an initialisation message to the gateway. This message contains the role that the tester wishes to authenticate as: $Role^8$. Because it is only 8 bits in size, it fits into a single CAN message (remember from Section \ref{subsec:can:frames}, that a CAN message can hold up to 64 bits of data). The gateway reacts to this message by creating a new ECC keypair: KGen($Pb_g^{512}$,$Pr_g^{256}$. The same curve must be used as the one chosen for the original OBD-II keys (i.e. secp256r1), otherwise the ECDH secret generation algorithm used later on will not work. As a result of this, both key pairs have the same respective sizes. Next, the newly generated public key $Pb_g^{512}$ is transmitted to the tester. Because of it's size (512 bits), this key won't fit into a single CAN message. This problem is overcome by spreading the key over 8 distinct CAN messages, and sending them to the tester one by one. After the tester has received all 8 messages, and has assembled the public key, it will first hash it using SHA512: SHA512($Pb_g^{512}$). For this operation the AVR cryptolib\footnote{\url{https://github.com/cantora/avr-crypto-lib}} C library was chosen. After calculating the hash value, the signing function of the key API is called: Sig(SHA512($Pb_g^{512}$),$Pr_{obd}^{256}$). This results in the signature being generated: $S^{512}$. The size of our signature is determined by our choice of curve; our curve corresponds to a signature size of 512 bits. Once the signature is generated, it sent to the gateway. Because the signature is the same size as the public key that was sent earlier, it is also spread over 8 different CAN messages. Upon reception, the gateway verifies the validity of the signature by first hashing it with the same hash function used in its generation (SHA512), before running the ECDSA verification procedure: Ver(SHA512($S^{512}$),$Pb_{obd}^{512}$). If and when the verification is successful, an ACK message is transmitted to the tester. Both tester and gateway can now generate the shared secret: ECDH($Pr_{obd}^{256}$,$Pb_g^{512}$) and ECDH($Pr_g^{256}$,$Pb_{obd}^{512}$), which will be used in the message authentication procedure.

\begin{figure}[h]
	\centering
	\fbox{
		\procedure{OBD-II authenticated key agreement procedure implementation}{%
			\textbf{Tester}  \<\< \textbf{Gateway} \\
			\text{$Pr_{obd}^{256}$} \<\< \text{$Pb_{obd}^{512}$} \\
			\< \sendmessageright{top=\text{$Role^8$ (1 frame)}} \<\\
			\<\< \text{KGen($Pb_g^{512}$,$Pr_g^{256}$)} \\
			\< \sendmessageleft{top=\text{$Pb_g^{512}$ (8 frames)}} \<\\
			\text{$S^{512}$=Sig(SHA512($Pb_g^{512}$),$Pr_{obd}^{256}$)} \<\<\<\< \\
			\< \sendmessageright{top=\text{$S^{512}$ (8 frames)}} \<\\
			\<\< \text{Ver(SHA512($S^{512}$),$Pb_{obd}^{512}$)} \\
			\< \sendmessageleft{top=\text{$ACK^{8}$ (1 frame)}} \<\\
			\text{$K^{256}$=ECDH($Pr_{obd}^{256}$,$Pb_g^{512}$)} \<\< \text{$K^{256}$=ECDH($Pr_g^{256}$,$Pb_{obd}^{512}$)} \\
		}
	}
	\caption{OBD-II authenticated key agreement procedure implementation.}
	\label{fig:authentication_procedure_implementation}
\end{figure}



\subsubsection{Message Authentication Procedure Implementation}
\label{subsec:message_authentication_procedure_implementation}

Figure \ref{fig:message_authentication_implementation} shows the implementation of the message authentication procedure. After the procedure from Section \ref{subsec:authenticated_key_agreement_procedure_implementation} completes, and the shared secret $K$ is established, this procedure is repeated for every OBD-II message sent by the tester. The procedure starts when the tester sends the message $M^{64}$ (again superscript is used to indicate the size). The gateway receives the message and checks the permissions table: CheckP($M^{64}$) (see Section \ref{subsec:permissions_table_implementation}), before sending an acknowledgement back to the tester: $ACK^8$. This acknowledgement is positive or negative based on the outcome of the earlier permissions table check. Upon reception of the acknowledgement, the tester calculates the MAC of the message using the shared secret and HMAC\textunderscore SHA256: $Mac^{256}$=Hmac\textunderscore SHA256($M$,$K$). For the HMAC\textunderscore SHA256 operation the AVR cryptolib library is used, just like we did for SHA512 in Section \ref{subsec:authenticated_key_agreement_procedure_implementation}. The size of this MAC is again mandated by our security guarantee of 128 bits. This is because the SHA265 cryptographic hash algorithm has a security level of 128 bits against collision attacks \cite{SHA256Collision}. The MAC is then sent to the Gateway, which will in turn verify it using the shared secret: Ver($Mac^{256}$,$K$). If the MAC is valid, the original message $M^{64}$ is forwarded to the intra vehicle network: Forward($M^{64}$), which in our implementation was indicated by sending a RS232 message to a connected PC. The tester is also informed of this by sending another acknowledgement. Upon reception the tester might want to send another message, in which case the entire procedure is repeated. 

\begin{figure}[h]
	\centering
	\fbox{
		\procedure{Message Authentication}{%
			\textbf{Tester}  \<\< \textbf{Gateway} \\
			\text{$K$}  \<\< \text{$K$} \\
			\< \sendmessageright{top=\text{OBD-II message $M^{64}$ (1 frame)}} \<\\
			\<\< \text{CheckP($M^{256}$)} \\
			\< \sendmessageleft{top=\text{$ACK^8$ (1 frame)}} \< \\
			\text{$Mac^{256}$=Hmac\textunderscore SHA256($M$,$K$) } \<\< \\
			\< \sendmessageright{top=\text{$Mac^{256}$} (4 frames)} \<\\
			\<\< \text{Ver($Mac^{256}$,$K$)}  \\
			\<\< \text{Forward($M^{64}$)}  \\
			\< \sendmessageleft{top=\text{$ACK^8$ (1 frame)}} \< \\
		}
	}
	\caption{OBD-II Message Authentication Implementation}
	\label{fig:message_authentication_implementation}
\end{figure}

\subsubsection{Permission Table Implementation}
\label{subsec:permissions_table_implementation}

The permission table is implemented according to the design of Section \ref{subsec:permissions_table}. Generally, a permission table for a RBAC system will use hash functions to map user names to fixed size indices. However, in our case the user names are replaced by CAN message ID's, which already have a fixed size of 11 bits (or 29 if the extended frame format is used), negating the need for any hash functions. Table \ref{table:roles} lists all the roles currently implemented, as well as their byte representation (This byte representation is also used in the $Role^{8}$ message of the authentication procedure in Section \ref{subsec:authenticated_key_agreement_procedure_implementation}). Table \ref{table:permissions} shows the implementation of the example of Table \ref{table:2} in Section \ref{subsec:permissions_table}. Every ID entry points to a data structure consisting of a series of bytes; each one associated with a role. The presence of a certain role in this series of bytes, indicates that this role has the permission to send a message with the aforementioned ID. Permissions are easily granted and revoked (Admin role) by deleting and adding role bytes to the data structure pointed to by the chosen ID. 

\begin{table}[]
	\centering
	\begin{tabular}{|c|c|c|c|c|}
		\hline
		\rowcolor[HTML]{9B9B9B} 
		Admin & OEM & Policeman & Repairman & Owner \\ \hline
		\rowcolor[HTML]{FFFFFF} 
		00000000 & 00000001 & 00000010 & 00000011 & 00000100 \\ \hline
	\end{tabular}
	\caption{Role implementation}
	\label{table:roles}
\end{table}

\begin{table}[]
	\adjustbox{max width=\textwidth}{%
	\begin{tabular}{|
			>{\columncolor[HTML]{9B9B9B}}c |c|
			>{\columncolor[HTML]{9B9B9B}}c |
			>{\columncolor[HTML]{9B9B9B}}c |
			>{\columncolor[HTML]{9B9B9B}}c 
			>{\columncolor[HTML]{9B9B9B}}c 
			>{\columncolor[HTML]{FFFFFF}}c }
	\hhline{-~-----}
	   IDH: 02, IDL: 01	& \begin{tikzpicture}[thick] \draw [black,  -latex] (0,6.5) -- (2,6.5); \end{tikzpicture} & 00000000 & 00000001 & \multicolumn{1}{c|}{\cellcolor[HTML]{9B9B9B} 00000010} & \multicolumn{1}{c|}{\cellcolor[HTML]{9B9B9B} 00000011}  & \multicolumn{1}{c|}{\cellcolor[HTML]{9B9B9B} 00000100}  \\ \hhline{-~-----} \multicolumn{1}{c}{\cellcolor[HTML]{FFFFFF}} & \multicolumn{1}{c}{\cellcolor[HTML]{FFFFFF}} & \multicolumn{1}{c}{\cellcolor[HTML]{FFFFFF}} & \multicolumn{1}{c}{\cellcolor[HTML]{FFFFFF}} & \multicolumn{1}{c}{\cellcolor[HTML]{FFFFFF}} & \multicolumn{1}{c}{\cellcolor[HTML]{FFFFFF}} &  \\ \hhline{-~---~~}
	   IDH: 04, IDL: 02	& \begin{tikzpicture}[thick] \draw [black,  -latex] (0,6.5) -- (2,6.5); \end{tikzpicture} & 00000000 & 00000001 & \multicolumn{1}{c|}{\cellcolor[HTML]{9B9B9B} 00000011} & \multicolumn{1}{c}{\cellcolor[HTML]{FFFFFF}} &                                               \\ \hhline{-~---~~} \multicolumn{1}{c}{\cellcolor[HTML]{FFFFFF}} & \multicolumn{1}{c}{\cellcolor[HTML]{FFFFFF}} & \multicolumn{1}{c}{\cellcolor[HTML]{FFFFFF}} & \multicolumn{1}{c}{\cellcolor[HTML]{FFFFFF}} & \multicolumn{1}{c}{\cellcolor[HTML]{FFFFFF}} & \multicolumn{1}{c}{\cellcolor[HTML]{FFFFFF}} & \\ \hhline{-~--~~~}
	   IDH: 00, IDL: 00	& \begin{tikzpicture}[thick] \draw [black,  -latex] (0,6.5) -- (2,6.5); \end{tikzpicture} & 00000000 & 00000001 & \cellcolor[HTML]{FFFFFF}                      & \cellcolor[HTML]{FFFFFF} &                                         \\ \cline{1-1} \cline{3-4}
	\end{tabular}}
	\caption{Permissions table implementation.}
	\label{table:permissions}
\end{table}


\section{Evaluation}
\label{chap:evaluation}

As mentioned in Section \ref{sec:challenges}, the main challenges of this research topic are the portability, speed and security of our proposed system. namely, the OBD-II access control system that is introduced in Chapter \ref{chap:solution}. After introducing the demo implementation in Section \ref{sec:implementation}, it is time to assess whether it meets the aforementioned challenges; proving the feasibility of it's design. This chapter is structured according to our three challenges. First, the overall portability of the system is quantified, by looking at the memory footprint of the software that is deployed on our gateway microcontroller. Second,  we look at the speed it takes to perform the various procedures. Third, the overall security is determined by surveying any potential vulnerabilities. 

\subsection{Portability}
\label{sec:portability}

The portability of our system refers to the ease at which it is introduced in extant vehicle networks. A system that consists of introducing specific hardware, requiring lots of modifications to be made to the vehicle, is unsuitable. Our system consists of introducing additional code to the gateway. In theory, this would consists of simply reprogramming the gateway microcontroller. Granted, the size of the code that enforces the access control system, is bounded by the memory specifications of the gateway. This is why the size of the code that is introduced to the gateway should be kept as small as possible. As an indication, we can take a look at the size of the code of our demo. 

\paragraph{Results}
The total memory footprint (program memory) of our gateway implementation is given in Table \ref{table:portability}. The HMAC\_SHA2 portion refers to the code that implements both SHA hash functions (SHA256 and SHA512), as well as the HMAC\_SHA2 MAC generation and verification algorithms. The ECC portion refers to the code that is used to perform all ECC operations (ECC key pair generation, ECDSA signature verification and ECDH shared secret generation). The last portion (Rest) refers to all other code that is introduced to implement the gateway. Additionally, by analysing the gateway during operation, we saw that no more than 3 Kb is used for data memory at any time (RAM). Non surprisingly, this peak is reached during the computation of the heaviest cryptographic primitive, which is ECC.

\begin{table}[]
	\centering
	\begin{tabular}{|c|c|c|c||c|}
		\hline
		\rowcolor[HTML]{9B9B9B} Type & SHA2 & ECC & Rest (CAN, UART, etc.) & Total \\ \hline
		\cellcolor[HTML]{9B9B9B} Size (Kb) & \cellcolor[HTML]{FFFFFF} 2,706 & 18,762 & 10,384 & 31,852 \\ \hline
	\end{tabular}
	\caption{Program memory footprint of implementation on a resource constrained microcontroller.}
	\label{table:portability}
\end{table}

\paragraph{Discussion} The first thing to consider is the data memory (RAM). A peak of 3 Kb is certainly within acceptable bounds, especially if we consider that some automotive gateway microcontrollers that are sold today have a RAM memory of up to several megabytes \cite{GatewayInfineon,GatewayST}. However, it is not unthinkable for some old extant gateway ECU's to lack the necessary RAM to implement our solution. Next, we consider the program memory footprint presented in Table \ref{table:portability}. It should be noted that the total memory footprint of 31,852 Kb is not indicative of the footprint of a real implementation. This is because a typical gateway will have already implemented a lot of functions before introduction of OBD-II RBAC (e.g. CAN object layer). Nonetheless, a total program data size of 31,852 Kb is again within acceptable bounds, since currently sold automotive gateway microcontrollers typically have program memories far exceeding this number \cite{GatewayInfineon,GatewayAtmel,GatewayST}. \\ \\ In short, we can assume that our solution ports well to existing gateway ECU's. There is always a chance that some old gateway microcontroller is not able to support it. Indeed, this chance only increases when older cars are considered, but it is our opinion that this is to be expected.  


\subsection{Speed}
\label{sec:speed}

The speed of our proposed system is of great importance. This is mainly due to the real-time nature of vehicle networks. Messages that are transmitted over different sub-networks, thereby passing through the gateway, need to be delivered as fast as possible. Significant message delays could result in the failure of critical systems (e.g. engine control, ABS, powertrain, etc.). If the authentication scheme proposed in Section \ref{subsec:authenticated_key_agreement_procedure} takes to long to perform, it could cause the gateway to effectively abandon it's other operations. This is also the case for the message authentication procedure presented in Section \ref{subsec:message_authentication_procedure_implementation}. Moreover, a significant delay introduced here could effectively impede the function of the OBD-II interface. This is because a lot of diagnostic and maintenance operations require multiple messages to be sent in sequence. The introduced delays could prohibit the ECU's from recognizing and accepting these sequences. Also, if normal CAN messages are injected to test certain systems, a real-time performance is definitely required here. To evaluate the speed performance of our system, the aforementioned procedures are key. 

\paragraph{Results}
We've mentioned before that asymmetric cryptographic operations are computationally hard to perform; especially on platforms with limited processing power, as is the case here. The authenticated key agreement procedure of our proposed system introduces three ECC operations performed on the gateway: Generating a new public key pair (KGen), Verifying the signature that is received from the tester (Ver), and the generation of the shared secret (ECDH). The message authentication procedure only includes one significant cryptographic operation: the MAC verification (Ver). The performance of all of these procedures is given in Table \ref{table:eval1}. We skipped over the operations that are performed by the tester (calling the central server for the signature, as well as also generating a shared secret). This is because any tester device would be designed with these operations in mind, introducing dedicated hardware that allows fast and efficient shared secret generation. As well as a fast and secure way of interfacing with the central server. We also omitted the time it takes to send the CAN messages themselves. Considering our CAN controller is set to a baud rate of 125 Kbps, we can use \cite{CANspeed} to calculate that every message takes roughly 1.04 milliseconds to transmit. This indicates that the performance of our design is dominated by the cryptographic operations that were introduced, rather than the amount of transmitted CAN messages.  
\begin{table}[]
	\adjustbox{max width=\textwidth}{%
	\begin{tabular}{|c|ccc||c|}
		\hline
		\rowcolor[HTML]{9B9B9B} Procedure & Authenticated & Key & Agreement & Message Authentication \\ \hline
		\cellcolor[HTML]{9B9B9B} Cryptographic Operation & \multicolumn{1}{c|}{\cellcolor[HTML]{FFFFFF} KGen } & \multicolumn{1}{c|}{Ver (ECDSA)} & ECDH & Ver (MAC) \\ \hline
		\cellcolor[HTML]{9B9B9B} Performance (seconds) & \multicolumn{1}{c|}{8,593} & \multicolumn{1}{c|}{10,16} & 8,565 & 0,124 \\ \hline
	\end{tabular}}
	\caption{Performance of cryptographic operations on a resource constrained microcontroller.}
	\label{table:eval1}
\end{table}

\paragraph{Discussion} The first takeaway from the results of our evaluation presented in Table \ref{table:eval1}, is that the cryptographic operations of the authenticated key agreement procedure take long to perform; each one taking roughly 9 seconds to complete. This in line with our expectations, since we know that asymmetric key operations are computationally very intensive. Indeed, if we compare them to the symmetric key operation performed in the message authentication procedure, which takes only 124 milliseconds, this distinction becomes even more apparent. Remember that the decision was made to use a resource constrained microcontroller, with a CPU clock speed of only 8 MHz and word size of 8 bits. Actual automotive gateway microcontrollers that are sold today have clock speeds ranging from 8 up to 300 MHz and word sizes of 8, 16, or 32 bits \cite{GatewayInfineon,GatewayAtmel,GatewayST}. Some of these even incorporate hardware accelerators for ECC and SHA2 operations \cite{GatewayInfineon}. Therefore, if our solution were implemented on real automotive gateways, our performance would likely increase. Nonetheless, the time it takes to complete the authenticated key agreement procedure is significant. If a gateway were to initiate this sequence while in operation (i.e. the car is driving), all internal network communications would have to be postponed for roughly 30 seconds, which would be disastrous. To solve this issue, we assert that internal network communications should have precedence over the OBD-II authentication procedure. This means that the system could reject any OBD-II authentication attempts while driving. Alternatively, an interrupt can be generated every time an internal message is received, postponing the authentication procedure until the message is handled. This scenario becomes increasingly likely when we consider that a lot of modern ECU's provide a dual-processor with service separation \cite{GatewayPerformance}. Here, a dedicated processor would handle incoming messages, thereby preventing the OBD-II procedures from interfering. \\ \\ While the running times of the authentication procedure are long, they are only required for the initial authentication. Once this is done, the message authentication procedure takes over. This procedure introduces three delays: the signature generation on the tester, the permissions check and the MAC verification (we mentioned earlier that message transmission times are not considered). Signature generation doesn't incur any real delay, since the tester would generate the signature, and send the message and the signature back-to-back. Since every CAN ID is finite (i.e. 11 bits for our demo), every permission table lookup can be completed in constant time, so this delay is take out of consideration as well. We can conclude that the performance of the message authentication procedure is dominated by the MAC verification, which takes only 124 milliseconds. \\ \\ To conclude, the design of our solution is feasible in terms of performance. However, the authenticated key agreement procedure is slow, and if performed in one pass, would indeed impede the operation of the internal network. This is why care must be taken not to let the OBD-II authentication procedure interfere with internal communications/ This can be facilitated in two ways: rejecting OBD-II authentication while driving or decoupling OBD-II RBAC operations from other gateway functions by using interrupts or dual-processing technologies. 


\subsection{Security}
\label{sec:security}

The most intrinsic property of any RBAC system is it's security, and OBD-II access control is certainly no exception. The goal of our system is to curtail the wide open nature of the OBD-II interface; forcing individuals to garner the right credentials, before access is granted. If the procedures that were introduced to enforce these goals are flawed, thereby allowing them to be easily bypassed, the design of our system has critically failed. To systematically evaluate the security of our system, we will attempt to survey any potential weaknesses.


\paragraph{Cryptographic Primitives} An obvious potential weakness of our system is the cryptographic primitives themselves: the ECC keys and operations, the hash functions and of course the MAC verification process. A weakness in any of these would present a significant security breach. Imagine if the ECC signatures could be easily calculated without possession of the appropriate private key. Or if MAC messages could be replayed in an effort to hijack extant sessions. To guarantee the security of these primitives, three things need to be assured. First, the original design should universally be considered sound and secure, allowing them to be used in professional applications. Luckily this is the case for all the primitives included in our solution: all ECC operations, HMAC\textunderscore SHA256 and SHA512. Second, the size of the keys and signatures should be sufficiently large. Again, this is the case since all of them were chosen to guarantee a security level of 128 bits. Third, the implementation of these primitives should not contain any flaws, allowing them to be broken. The burden of guaranteeing this lies with the OEM's themselves, since they would eventually be implementing them in vehicles all over the world. 

\paragraph{Authenticated Key Agreement Procedure}
Remember from Section \ref{sec:attacker_model} that we consider two basic attack scenarios: an attacker directly interfacing with the OBD-II port (Figure \ref{fig:attackmodel_1}) and an attacker hijacking an extant session remotely (Figure \ref{fig:attackmodel_2}). The first scenario is directly linked with the authentication procedure. This procedure was based on the ECDHE\textunderscore ECDSA procedure introduced in \cite{RFC4492}, so it's safe to assume our design inherits the same security guarantees. However, we did introduce some changes; we need to make sure these changes do not jeopardise the overall security of the procedure. Next, we take a look at these changes one-by-one, ensuring they are harmless.
\begin{itemize}
	\item \textbf{Gateway Key Pair:} The generation of a new ECC key pair was introduced on the gateway since both parties require a key pair for the ECDH operations. The only difference with the original ECDHE\textunderscore ECDSA system is that this pair is generated on the fly for the gateway. When generating this key pair, it must be assured that they are random. If they were not, this would allow individuals to predict them. The problem of random number generation is discussed in the next paragraph.
	
	\item \textbf{Perfect Forward Secrecy:} We already discussed why PFS is not a concern for our system. Omitting the ephemeral key pairs results in a more efficient system without having an adverse effect on it's security.
	
	\item \textbf{Mutual Authentication:} The omission of two way authentication is necessary because of the initial absence of an ECC key pair on the gateway. In the end, the only security property that is lost here is authentication of the gateway, which is not necessary since the user should be aware whether (s)he is interfacing with a legitimate gateway or not.
\end{itemize} 

\paragraph{Random Number Generation} As mentioned before, a sound random number generator (RNG) is essential to the security of our system. RNG's are difficult to implement because of the deterministic nature of computers. A software RNG with a known seed will always generate the same sequence of numbers, allowing them to be predicted when the RNG procedure and seed are known (e.g. by reverse engineering the gateway). This is why it is often implemented by using sources that are inherently unpredictable: the noise on a network bus, the value of a sensor, the contents of an arbitrary memory location, etc. Hash functions can also be useful here to provide an extra layer of entropy. 

\paragraph{Message Authentication Procedure}
The message authentication procedure is more concerned with our second attack scenario; namely, remote session hacking. This is because the MAC's were introduced to ensure that the messages were transmitted by the authenticated user (i.e. the user that successfully performed the authentication procedure). Our procedure follows the general structure of any MAC system: a message is sent together with a MAC of the message. Any adversary that has the ability to read and inject messages into this session is limited in terms of attack capabilities. Altering extant messages is impossible, since this would invalidate the MAC. Injecting messages is also impossible since the attacker would have to generate a MAC, and this requires knowledge of the session key. They could flood the system with messages to shut down the session. Or intercept valid messages that were sent by the user. These problems can only be solved by securing the remote connection itself.  

\paragraph{Central Server Connection} With the introduction of the central server, we have unintentionally introduced a third attack vector: the connection to the central server. If these connection were insecure, it would allow third parties to monitor and interfere with the signature transmission. While this may seem harmless, it does open up the ability of systematically collecting signature/public key pairs for a specific car model, allowing them to be replayed in the future whenever the same public key is generated. Luckily, the cost in terms of time and effort is immense, which might prevent anyone from ever attempting it. Nonetheless, a secure internet connection is certainly a must.

\paragraph{Private Key Disclosure} It is essential that the OBD-II private keys are securely stored on the central server. Disclosure of these keys would invalidate the entire system, requiring the introduction of new public keys in all vehicles that support our solution. Luckily, secure servers are commonplace on the internet, so it's just a matter of employing the appropriate technologies. Besides the OBD-II private keys, there's also the private key that is generated on the gateway, as well as the shared secret. We do not protect against physical access, so an adversary analysing a gateway and extracting the newly generated private key is possible (although it seems futile, since physical access would allow the attacker to bypass the RBAC system altogether). Only protected memory architectures would solve this issue. However, if a software vulnerability is introduced that discloses the private key or session key on the CAN bus, this would be disastrous and should be avoided at all times.

\paragraph{Permission Table} The permission table introduces the same issue as before. If someone has physical access to the gateway, (s)he can modify the permissions table. Again this attack is only solvable by introducing sections of protected memory. The system will undoubtedly include admin messages that are designed to modify the security policy (i.e. the permissions table). If an attacker is able to successfully transmit these messages, it would mean the OBD-II port is wide open once more.