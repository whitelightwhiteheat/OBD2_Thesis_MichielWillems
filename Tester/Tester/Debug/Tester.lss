
Tester.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001f0  00800100  00000d62  00000df6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000d62  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000b6  008002f0  008002f0  00000fe6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000fe6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001018  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001a8  00000000  00000000  00001058  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000034c0  00000000  00000000  00001200  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001436  00000000  00000000  000046c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000012f3  00000000  00000000  00005af6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000598  00000000  00000000  00006dec  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000e19  00000000  00000000  00007384  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001f9b  00000000  00000000  0000819d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000220  00000000  00000000  0000a138  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	49 c0       	rjmp	.+146    	; 0x94 <__ctors_end>
   2:	00 00       	nop
   4:	64 c0       	rjmp	.+200    	; 0xce <__bad_interrupt>
   6:	00 00       	nop
   8:	62 c0       	rjmp	.+196    	; 0xce <__bad_interrupt>
   a:	00 00       	nop
   c:	60 c0       	rjmp	.+192    	; 0xce <__bad_interrupt>
   e:	00 00       	nop
  10:	5e c0       	rjmp	.+188    	; 0xce <__bad_interrupt>
  12:	00 00       	nop
  14:	16 c5       	rjmp	.+2604   	; 0xa42 <__vector_5>
  16:	00 00       	nop
  18:	4b c5       	rjmp	.+2710   	; 0xab0 <__vector_6>
  1a:	00 00       	nop
  1c:	80 c5       	rjmp	.+2816   	; 0xb1e <__vector_7>
  1e:	00 00       	nop
  20:	b5 c5       	rjmp	.+2922   	; 0xb8c <__vector_8>
  22:	00 00       	nop
  24:	54 c0       	rjmp	.+168    	; 0xce <__bad_interrupt>
  26:	00 00       	nop
  28:	52 c0       	rjmp	.+164    	; 0xce <__bad_interrupt>
  2a:	00 00       	nop
  2c:	50 c0       	rjmp	.+160    	; 0xce <__bad_interrupt>
  2e:	00 00       	nop
  30:	4e c0       	rjmp	.+156    	; 0xce <__bad_interrupt>
  32:	00 00       	nop
  34:	4c c0       	rjmp	.+152    	; 0xce <__bad_interrupt>
  36:	00 00       	nop
  38:	4a c0       	rjmp	.+148    	; 0xce <__bad_interrupt>
  3a:	00 00       	nop
  3c:	48 c0       	rjmp	.+144    	; 0xce <__bad_interrupt>
  3e:	00 00       	nop
  40:	40 c1       	rjmp	.+640    	; 0x2c2 <__vector_16>
  42:	00 00       	nop
  44:	44 c0       	rjmp	.+136    	; 0xce <__bad_interrupt>
  46:	00 00       	nop
  48:	42 c0       	rjmp	.+132    	; 0xce <__bad_interrupt>
  4a:	00 00       	nop
  4c:	40 c0       	rjmp	.+128    	; 0xce <__bad_interrupt>
  4e:	00 00       	nop
  50:	3e c0       	rjmp	.+124    	; 0xce <__bad_interrupt>
  52:	00 00       	nop
  54:	3c c0       	rjmp	.+120    	; 0xce <__bad_interrupt>
  56:	00 00       	nop
  58:	3a c0       	rjmp	.+116    	; 0xce <__bad_interrupt>
  5a:	00 00       	nop
  5c:	38 c0       	rjmp	.+112    	; 0xce <__bad_interrupt>
  5e:	00 00       	nop
  60:	36 c0       	rjmp	.+108    	; 0xce <__bad_interrupt>
  62:	00 00       	nop
  64:	34 c0       	rjmp	.+104    	; 0xce <__bad_interrupt>
  66:	00 00       	nop
  68:	32 c0       	rjmp	.+100    	; 0xce <__bad_interrupt>
  6a:	00 00       	nop
  6c:	30 c0       	rjmp	.+96     	; 0xce <__bad_interrupt>
  6e:	00 00       	nop
  70:	2e c0       	rjmp	.+92     	; 0xce <__bad_interrupt>
  72:	00 00       	nop
  74:	2c c0       	rjmp	.+88     	; 0xce <__bad_interrupt>
  76:	00 00       	nop
  78:	2a c0       	rjmp	.+84     	; 0xce <__bad_interrupt>
  7a:	00 00       	nop
  7c:	28 c0       	rjmp	.+80     	; 0xce <__bad_interrupt>
  7e:	00 00       	nop
  80:	26 c0       	rjmp	.+76     	; 0xce <__bad_interrupt>
  82:	00 00       	nop
  84:	24 c0       	rjmp	.+72     	; 0xce <__bad_interrupt>
  86:	00 00       	nop
  88:	22 c0       	rjmp	.+68     	; 0xce <__bad_interrupt>
  8a:	00 00       	nop
  8c:	20 c0       	rjmp	.+64     	; 0xce <__bad_interrupt>
  8e:	00 00       	nop
  90:	1e c0       	rjmp	.+60     	; 0xce <__bad_interrupt>
	...

00000094 <__ctors_end>:
  94:	11 24       	eor	r1, r1
  96:	1f be       	out	0x3f, r1	; 63
  98:	cf ef       	ldi	r28, 0xFF	; 255
  9a:	d0 e1       	ldi	r29, 0x10	; 16
  9c:	de bf       	out	0x3e, r29	; 62
  9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
  a0:	12 e0       	ldi	r17, 0x02	; 2
  a2:	a0 e0       	ldi	r26, 0x00	; 0
  a4:	b1 e0       	ldi	r27, 0x01	; 1
  a6:	e2 e6       	ldi	r30, 0x62	; 98
  a8:	fd e0       	ldi	r31, 0x0D	; 13
  aa:	00 e0       	ldi	r16, 0x00	; 0
  ac:	0b bf       	out	0x3b, r16	; 59
  ae:	02 c0       	rjmp	.+4      	; 0xb4 <__do_copy_data+0x14>
  b0:	07 90       	elpm	r0, Z+
  b2:	0d 92       	st	X+, r0
  b4:	a0 3f       	cpi	r26, 0xF0	; 240
  b6:	b1 07       	cpc	r27, r17
  b8:	d9 f7       	brne	.-10     	; 0xb0 <__do_copy_data+0x10>

000000ba <__do_clear_bss>:
  ba:	23 e0       	ldi	r18, 0x03	; 3
  bc:	a0 ef       	ldi	r26, 0xF0	; 240
  be:	b2 e0       	ldi	r27, 0x02	; 2
  c0:	01 c0       	rjmp	.+2      	; 0xc4 <.do_clear_bss_start>

000000c2 <.do_clear_bss_loop>:
  c2:	1d 92       	st	X+, r1

000000c4 <.do_clear_bss_start>:
  c4:	a6 3a       	cpi	r26, 0xA6	; 166
  c6:	b2 07       	cpc	r27, r18
  c8:	e1 f7       	brne	.-8      	; 0xc2 <.do_clear_bss_loop>
  ca:	7b d5       	rcall	.+2806   	; 0xbc2 <main>
  cc:	48 c6       	rjmp	.+3216   	; 0xd5e <_exit>

000000ce <__bad_interrupt>:
  ce:	98 cf       	rjmp	.-208    	; 0x0 <__vectors>

000000d0 <can_init>:
void can_init_mask (can_mask_t mask){
	CANIDM2 = mask[0] << 5;
	CANIDM1 = mask[0] >> 3 | mask[1] << 5;
	//RTRMSK = 0 : We don't use remote frames ever.
	//IDEMSK = 0 : we don't use the extended format.
	CANIDM4 = (0 << RTRMSK) | (0 << IDEMSK);
  d0:	f8 94       	cli
  d2:	81 e0       	ldi	r24, 0x01	; 1
  d4:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
  d8:	84 e3       	ldi	r24, 0x34	; 52
  da:	80 93 db 00 	sts	0x00DB, r24	; 0x8000db <__TEXT_REGION_LENGTH__+0x7e00db>
  de:	10 92 da 00 	sts	0x00DA, r1	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
  e2:	20 e0       	ldi	r18, 0x00	; 0
  e4:	82 2f       	mov	r24, r18
  e6:	82 95       	swap	r24
  e8:	80 7f       	andi	r24, 0xF0	; 240
  ea:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
  ee:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
  f2:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
  f6:	88 e0       	ldi	r24, 0x08	; 8
  f8:	90 e0       	ldi	r25, 0x00	; 0
  fa:	10 92 fa 00 	sts	0x00FA, r1	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7e00fa>
  fe:	01 97       	sbiw	r24, 0x01	; 1
 100:	e1 f7       	brne	.-8      	; 0xfa <can_init+0x2a>
 102:	2f 5f       	subi	r18, 0xFF	; 255
 104:	2f 30       	cpi	r18, 0x0F	; 15
 106:	71 f7       	brne	.-36     	; 0xe4 <can_init+0x14>
 108:	88 e0       	ldi	r24, 0x08	; 8
 10a:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
 10e:	86 e0       	ldi	r24, 0x06	; 6
 110:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
 114:	8c e0       	ldi	r24, 0x0C	; 12
 116:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
 11a:	87 e3       	ldi	r24, 0x37	; 55
 11c:	80 93 e4 00 	sts	0x00E4, r24	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>
 120:	10 92 e5 00 	sts	0x00E5, r1	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>
 124:	82 e0       	ldi	r24, 0x02	; 2
 126:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
 12a:	78 94       	sei
 12c:	08 95       	ret

0000012e <can_init_message>:
}

void can_init_message( uint8_t *message , uint8_t mobnr, uint8_t size){
 12e:	fc 01       	movw	r30, r24
 130:	49 30       	cpi	r20, 0x09	; 9
 132:	08 f0       	brcs	.+2      	; 0x136 <can_init_message+0x8>
 134:	48 e0       	ldi	r20, 0x08	; 8
		sei();

}

static void set_page(uint8_t mobnr){
	CANPAGE = (mobnr << 4) | PAGE_MASK;
 136:	80 e1       	ldi	r24, 0x10	; 16
 138:	68 9f       	mul	r22, r24
 13a:	b0 01       	movw	r22, r0
 13c:	11 24       	eor	r1, r1
 13e:	68 60       	ori	r22, 0x08	; 8
 140:	60 93 ed 00 	sts	0x00ED, r22	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>

void can_init_message( uint8_t *message , uint8_t mobnr, uint8_t size){
	if(size > 8) size = 8;
	set_page(mobnr);
	uint8_t j;
	for(j=0; j<size; j++){
 144:	44 23       	and	r20, r20
 146:	59 f0       	breq	.+22     	; 0x15e <can_init_message+0x30>
 148:	90 e0       	ldi	r25, 0x00	; 0
static void set_page(uint8_t mobnr){
	CANPAGE = (mobnr << 4) | PAGE_MASK;
}

static void set_page_indx(uint8_t indx, uint8_t mobnr){
	CANPAGE = (mobnr << 4) | PAGE_MASK | indx;
 14a:	86 2f       	mov	r24, r22
 14c:	89 2b       	or	r24, r25
 14e:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
	if(size > 8) size = 8;
	set_page(mobnr);
	uint8_t j;
	for(j=0; j<size; j++){
		set_page_indx(j, mobnr);
		CANMSG = *message;
 152:	81 91       	ld	r24, Z+
 154:	80 93 fa 00 	sts	0x00FA, r24	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7e00fa>

void can_init_message( uint8_t *message , uint8_t mobnr, uint8_t size){
	if(size > 8) size = 8;
	set_page(mobnr);
	uint8_t j;
	for(j=0; j<size; j++){
 158:	9f 5f       	subi	r25, 0xFF	; 255
 15a:	94 13       	cpse	r25, r20
 15c:	f6 cf       	rjmp	.-20     	; 0x14a <can_init_message+0x1c>
static void set_page(uint8_t mobnr){
	CANPAGE = (mobnr << 4) | PAGE_MASK;
}

static void set_page_indx(uint8_t indx, uint8_t mobnr){
	CANPAGE = (mobnr << 4) | PAGE_MASK | indx;
 15e:	60 93 ed 00 	sts	0x00ED, r22	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
		set_page_indx(j, mobnr);
		CANMSG = *message;
		message++;
	}
	set_page_indx(0, mobnr);
	CANCDMOB |= size; 
 162:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
 166:	48 2b       	or	r20, r24
 168:	40 93 ef 00 	sts	0x00EF, r20	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
 16c:	08 95       	ret

0000016e <can_send_message>:
}

int can_send_message( uint8_t mobnr , can_id_t id, can_msg_t message, uint8_t size){
 16e:	fb 01       	movw	r30, r22
 170:	da 01       	movw	r26, r20
		sei();

}

static void set_page(uint8_t mobnr){
	CANPAGE = (mobnr << 4) | PAGE_MASK;
 172:	40 e1       	ldi	r20, 0x10	; 16
 174:	84 9f       	mul	r24, r20
 176:	b0 01       	movw	r22, r0
 178:	11 24       	eor	r1, r1
 17a:	68 60       	ori	r22, 0x08	; 8
 17c:	60 93 ed 00 	sts	0x00ED, r22	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
	id[0] = CANIDT2 >> 5 | CANIDT1 << 3;
	id[1] = CANIDT1 >> 5;
}

void can_init_id ( can_id_t id){
	CANIDT2 = id[0] << 5;
 180:	90 81       	ld	r25, Z
 182:	92 95       	swap	r25
 184:	99 0f       	add	r25, r25
 186:	90 7e       	andi	r25, 0xE0	; 224
 188:	90 93 f2 00 	sts	0x00F2, r25	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
	CANIDT1 = id[0] >> 3 | id[1] << 5;
 18c:	30 81       	ld	r19, Z
 18e:	36 95       	lsr	r19
 190:	36 95       	lsr	r19
 192:	36 95       	lsr	r19
 194:	91 81       	ldd	r25, Z+1	; 0x01
 196:	40 e2       	ldi	r20, 0x20	; 32
 198:	94 9f       	mul	r25, r20
 19a:	b0 01       	movw	r22, r0
 19c:	11 24       	eor	r1, r1
 19e:	63 2b       	or	r22, r19
 1a0:	60 93 f3 00 	sts	0x00F3, r22	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
	//not a remote frame.
	CANIDT4 = 0 << RTRTAG;
 1a4:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
	//select mob.
	set_page(mobnr);
	//copy ID.
	can_init_id(id);
	//copy message.
	can_init_message(message, mobnr, size);
 1a8:	42 2f       	mov	r20, r18
 1aa:	68 2f       	mov	r22, r24
 1ac:	cd 01       	movw	r24, r26
 1ae:	bf df       	rcall	.-130    	; 0x12e <can_init_message>
	//enable transmission.
	CANCDMOB |= (1 << CONMOB0);
 1b0:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
 1b4:	80 64       	ori	r24, 0x40	; 64
 1b6:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
	//wait for transmission.
	while(CANSTMOB != (1 << TXOK));
 1ba:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
 1be:	80 34       	cpi	r24, 0x40	; 64
 1c0:	e1 f7       	brne	.-8      	; 0x1ba <can_send_message+0x4c>
	//reset mob.
	CANSTMOB = 0x00;
 1c2:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
	CANCDMOB = 0x00;
 1c6:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
	return 0;
}
 1ca:	80 e0       	ldi	r24, 0x00	; 0
 1cc:	90 e0       	ldi	r25, 0x00	; 0
 1ce:	08 95       	ret

000001d0 <can_receive_message>:

int can_receive_message( uint8_t mobnr, can_id_t id, can_mask_t mask, can_msg_t message , uint8_t *len){
 1d0:	0f 93       	push	r16
 1d2:	1f 93       	push	r17
 1d4:	cf 93       	push	r28
 1d6:	df 93       	push	r29
 1d8:	eb 01       	movw	r28, r22
 1da:	da 01       	movw	r26, r20
 1dc:	f9 01       	movw	r30, r18
		sei();

}

static void set_page(uint8_t mobnr){
	CANPAGE = (mobnr << 4) | PAGE_MASK;
 1de:	40 e1       	ldi	r20, 0x10	; 16
 1e0:	84 9f       	mul	r24, r20
 1e2:	90 01       	movw	r18, r0
 1e4:	11 24       	eor	r1, r1
 1e6:	92 2f       	mov	r25, r18
 1e8:	98 60       	ori	r25, 0x08	; 8
 1ea:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
	return 0;
}

int can_receive_message( uint8_t mobnr, can_id_t id, can_mask_t mask, can_msg_t message , uint8_t *len){
	set_page(mobnr);
	CANIE2 = (1 << mobnr);
 1ee:	21 e0       	ldi	r18, 0x01	; 1
 1f0:	30 e0       	ldi	r19, 0x00	; 0
 1f2:	01 c0       	rjmp	.+2      	; 0x1f6 <can_receive_message+0x26>
 1f4:	22 0f       	add	r18, r18
 1f6:	8a 95       	dec	r24
 1f8:	ea f7       	brpl	.-6      	; 0x1f4 <can_receive_message+0x24>
 1fa:	20 93 de 00 	sts	0x00DE, r18	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
	id[0] = CANIDT2 >> 5 | CANIDT1 << 3;
	id[1] = CANIDT1 >> 5;
}

void can_init_id ( can_id_t id){
	CANIDT2 = id[0] << 5;
 1fe:	88 81       	ld	r24, Y
 200:	82 95       	swap	r24
 202:	88 0f       	add	r24, r24
 204:	80 7e       	andi	r24, 0xE0	; 224
 206:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
	CANIDT1 = id[0] >> 3 | id[1] << 5;
 20a:	28 81       	ld	r18, Y
 20c:	42 2f       	mov	r20, r18
 20e:	46 95       	lsr	r20
 210:	46 95       	lsr	r20
 212:	46 95       	lsr	r20
 214:	89 81       	ldd	r24, Y+1	; 0x01
 216:	50 e2       	ldi	r21, 0x20	; 32
 218:	85 9f       	mul	r24, r21
 21a:	90 01       	movw	r18, r0
 21c:	11 24       	eor	r1, r1
 21e:	24 2b       	or	r18, r20
 220:	20 93 f3 00 	sts	0x00F3, r18	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
	//not a remote frame.
	CANIDT4 = 0 << RTRTAG;
 224:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
	CANIDM4 = (0 << RTRMSK) | (0 << IDEMSK);
}
*/

void can_init_mask (can_mask_t mask){
	CANIDM2 = mask[0] << 5;
 228:	8c 91       	ld	r24, X
 22a:	82 95       	swap	r24
 22c:	88 0f       	add	r24, r24
 22e:	80 7e       	andi	r24, 0xE0	; 224
 230:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <__TEXT_REGION_LENGTH__+0x7e00f6>
	CANIDM1 = mask[0] >> 3 | mask[1] << 5;
 234:	2c 91       	ld	r18, X
 236:	52 2f       	mov	r21, r18
 238:	56 95       	lsr	r21
 23a:	56 95       	lsr	r21
 23c:	56 95       	lsr	r21
 23e:	11 96       	adiw	r26, 0x01	; 1
 240:	8c 91       	ld	r24, X
 242:	40 e2       	ldi	r20, 0x20	; 32
 244:	84 9f       	mul	r24, r20
 246:	90 01       	movw	r18, r0
 248:	11 24       	eor	r1, r1
 24a:	25 2b       	or	r18, r21
 24c:	20 93 f7 00 	sts	0x00F7, r18	; 0x8000f7 <__TEXT_REGION_LENGTH__+0x7e00f7>
	//RTRMSK = 0 : We don't use remote frames ever.
	//IDEMSK = 0 : we don't use the extended format.
	CANIDM4 = (0 << RTRMSK) | (0 << IDEMSK);
 250:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__TEXT_REGION_LENGTH__+0x7e00f4>
	set_page(mobnr);
	CANIE2 = (1 << mobnr);
	can_init_id(id);
	can_init_mask(mask);
	//CAN standard rev 2.0 A (identifiers length = 11 bits)
	CANCDMOB = (1 << CONMOB1) | (1 << DLC3); //enable reception and data length code = 8 bytes
 254:	88 e8       	ldi	r24, 0x88	; 136
 256:	80 93 ef 00 	sts	0x00EF, r24	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
	//wait for interrupt
	while((CANGIT & INTR_MASK) != (1 << CANIT));
 25a:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
 25e:	87 ff       	sbrs	r24, 7
 260:	fc cf       	rjmp	.-8      	; 0x25a <can_receive_message+0x8a>
	//check if it is the right interrupt.
	if((CANSTMOB & RXOK_MASK) != (1 << RXOK)) return 1;
 262:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
 266:	85 ff       	sbrs	r24, 5
 268:	25 c0       	rjmp	.+74     	; 0x2b4 <can_receive_message+0xe4>
		sei();

}

static void set_page(uint8_t mobnr){
	CANPAGE = (mobnr << 4) | PAGE_MASK;
 26a:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
}

void can_get_message(uint8_t mobnr , uint8_t *message , uint8_t *len){
	set_page(mobnr);
	uint8_t j;
	for(j=0; j<8; j++){
 26e:	80 e0       	ldi	r24, 0x00	; 0
static void set_page(uint8_t mobnr){
	CANPAGE = (mobnr << 4) | PAGE_MASK;
}

static void set_page_indx(uint8_t indx, uint8_t mobnr){
	CANPAGE = (mobnr << 4) | PAGE_MASK | indx;
 270:	29 2f       	mov	r18, r25
 272:	28 2b       	or	r18, r24
 274:	20 93 ed 00 	sts	0x00ED, r18	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
void can_get_message(uint8_t mobnr , uint8_t *message , uint8_t *len){
	set_page(mobnr);
	uint8_t j;
	for(j=0; j<8; j++){
		set_page_indx(j, mobnr);
		*message = CANMSG;
 278:	20 91 fa 00 	lds	r18, 0x00FA	; 0x8000fa <__TEXT_REGION_LENGTH__+0x7e00fa>
 27c:	21 93       	st	Z+, r18
}

void can_get_message(uint8_t mobnr , uint8_t *message , uint8_t *len){
	set_page(mobnr);
	uint8_t j;
	for(j=0; j<8; j++){
 27e:	8f 5f       	subi	r24, 0xFF	; 255
 280:	88 30       	cpi	r24, 0x08	; 8
 282:	b1 f7       	brne	.-20     	; 0x270 <can_receive_message+0xa0>
		set_page_indx(j, mobnr);
		*message = CANMSG;
		message++;
	}
	uint8_t mask = 0x0F;
	*len = CANCDMOB & 0x0F;
 284:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
 288:	8f 70       	andi	r24, 0x0F	; 15
 28a:	f8 01       	movw	r30, r16
 28c:	80 83       	st	Z, r24
static void set_page(uint8_t mobnr){
	CANPAGE = (mobnr << 4) | PAGE_MASK;
}

static void set_page_indx(uint8_t indx, uint8_t mobnr){
	CANPAGE = (mobnr << 4) | PAGE_MASK | indx;
 28e:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
	if((CANSTMOB & RXOK_MASK) != (1 << RXOK)) return 1;
	
	can_get_message(mobnr, message, len);
	
	//reset mob.
	CANSTMOB = 0x00;
 292:	10 92 ee 00 	sts	0x00EE, r1	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
	CANCDMOB = 0x00;
 296:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <__TEXT_REGION_LENGTH__+0x7e00ef>
	//reset interrupt enable
	CANIE2 = 0x00;
 29a:	10 92 de 00 	sts	0x00DE, r1	; 0x8000de <__TEXT_REGION_LENGTH__+0x7e00de>
	//reset interrupt register.
	CANGIT = CANGIT;
 29e:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
 2a2:	80 93 da 00 	sts	0x00DA, r24	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
	//retrieve message.
	return 0;
 2a6:	80 e0       	ldi	r24, 0x00	; 0
 2a8:	90 e0       	ldi	r25, 0x00	; 0
}
 2aa:	df 91       	pop	r29
 2ac:	cf 91       	pop	r28
 2ae:	1f 91       	pop	r17
 2b0:	0f 91       	pop	r16
 2b2:	08 95       	ret
	//CAN standard rev 2.0 A (identifiers length = 11 bits)
	CANCDMOB = (1 << CONMOB1) | (1 << DLC3); //enable reception and data length code = 8 bytes
	//wait for interrupt
	while((CANGIT & INTR_MASK) != (1 << CANIT));
	//check if it is the right interrupt.
	if((CANSTMOB & RXOK_MASK) != (1 << RXOK)) return 1;
 2b4:	81 e0       	ldi	r24, 0x01	; 1
 2b6:	90 e0       	ldi	r25, 0x00	; 0
	CANIE2 = 0x00;
	//reset interrupt register.
	CANGIT = CANGIT;
	//retrieve message.
	return 0;
}
 2b8:	df 91       	pop	r29
 2ba:	cf 91       	pop	r28
 2bc:	1f 91       	pop	r17
 2be:	0f 91       	pop	r16
 2c0:	08 95       	ret

000002c2 <__vector_16>:
#include <interrupt.h>

volatile uint32_t ms = 0;

ISR(TIMER0_COMP_vect)
{
 2c2:	1f 92       	push	r1
 2c4:	0f 92       	push	r0
 2c6:	0f b6       	in	r0, 0x3f	; 63
 2c8:	0f 92       	push	r0
 2ca:	11 24       	eor	r1, r1
 2cc:	8f 93       	push	r24
 2ce:	9f 93       	push	r25
 2d0:	af 93       	push	r26
 2d2:	bf 93       	push	r27
	ms = ms+1;
 2d4:	80 91 f0 02 	lds	r24, 0x02F0	; 0x8002f0 <__data_end>
 2d8:	90 91 f1 02 	lds	r25, 0x02F1	; 0x8002f1 <__data_end+0x1>
 2dc:	a0 91 f2 02 	lds	r26, 0x02F2	; 0x8002f2 <__data_end+0x2>
 2e0:	b0 91 f3 02 	lds	r27, 0x02F3	; 0x8002f3 <__data_end+0x3>
 2e4:	01 96       	adiw	r24, 0x01	; 1
 2e6:	a1 1d       	adc	r26, r1
 2e8:	b1 1d       	adc	r27, r1
 2ea:	80 93 f0 02 	sts	0x02F0, r24	; 0x8002f0 <__data_end>
 2ee:	90 93 f1 02 	sts	0x02F1, r25	; 0x8002f1 <__data_end+0x1>
 2f2:	a0 93 f2 02 	sts	0x02F2, r26	; 0x8002f2 <__data_end+0x2>
 2f6:	b0 93 f3 02 	sts	0x02F3, r27	; 0x8002f3 <__data_end+0x3>
}
 2fa:	bf 91       	pop	r27
 2fc:	af 91       	pop	r26
 2fe:	9f 91       	pop	r25
 300:	8f 91       	pop	r24
 302:	0f 90       	pop	r0
 304:	0f be       	out	0x3f, r0	; 63
 306:	0f 90       	pop	r0
 308:	1f 90       	pop	r1
 30a:	18 95       	reti

0000030c <millis>:

unsigned long int millis(void)
{
	return ms;
 30c:	60 91 f0 02 	lds	r22, 0x02F0	; 0x8002f0 <__data_end>
 310:	70 91 f1 02 	lds	r23, 0x02F1	; 0x8002f1 <__data_end+0x1>
 314:	80 91 f2 02 	lds	r24, 0x02F2	; 0x8002f2 <__data_end+0x2>
 318:	90 91 f3 02 	lds	r25, 0x02F3	; 0x8002f3 <__data_end+0x3>
}
 31c:	08 95       	ret

0000031e <clock_Init>:

void clock_Init(void)
{
	OCR0A = 61;
 31e:	8d e3       	ldi	r24, 0x3D	; 61
 320:	87 bd       	out	0x27, r24	; 39
	TIMSK0 = 1 << OCIE0A;
 322:	82 e0       	ldi	r24, 0x02	; 2
 324:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
	TCCR0A = 1 << WGM00 | 1 << WGM01 | 1 << CS01 | 1 << CS00;
 328:	8b e4       	ldi	r24, 0x4B	; 75
 32a:	84 bd       	out	0x24, r24	; 36
 32c:	08 95       	ret

0000032e <isotp_user_debug>:
#include "../uart_f.h"
#include "../can.h"

/* user implemented, print debug message */
void isotp_user_debug(const char* message){
	uart_puts(message);
 32e:	ca c4       	rjmp	.+2452   	; 0xcc4 <uart_puts>

00000330 <isotp_user_send_can>:
}

/* user implemented, send can message */
int  isotp_user_send_can(const uint32_t arbitration_id, const uint8_t* data, const uint8_t size){
 330:	cf 93       	push	r28
 332:	df 93       	push	r29
 334:	00 d0       	rcall	.+0      	; 0x336 <isotp_user_send_can+0x6>
 336:	cd b7       	in	r28, 0x3d	; 61
 338:	de b7       	in	r29, 0x3e	; 62
	can_msg_t message;
	can_id_t id;
	memcpy(id,arbitration_id,2);
 33a:	fb 01       	movw	r30, r22
 33c:	80 81       	ld	r24, Z
 33e:	91 81       	ldd	r25, Z+1	; 0x01
 340:	9a 83       	std	Y+2, r25	; 0x02
 342:	89 83       	std	Y+1, r24	; 0x01
	can_send_message(0, id, data, size);
 344:	be 01       	movw	r22, r28
 346:	6f 5f       	subi	r22, 0xFF	; 255
 348:	7f 4f       	sbci	r23, 0xFF	; 255
 34a:	80 e0       	ldi	r24, 0x00	; 0
 34c:	10 df       	rcall	.-480    	; 0x16e <can_send_message>
	uart_puts("message sent");
 34e:	80 e0       	ldi	r24, 0x00	; 0
 350:	91 e0       	ldi	r25, 0x01	; 1
 352:	b8 d4       	rcall	.+2416   	; 0xcc4 <uart_puts>
	return 0;
}
 354:	80 e0       	ldi	r24, 0x00	; 0
 356:	90 e0       	ldi	r25, 0x00	; 0
 358:	0f 90       	pop	r0
 35a:	0f 90       	pop	r0
 35c:	df 91       	pop	r29
 35e:	cf 91       	pop	r28
 360:	08 95       	ret

00000362 <isotp_user_get_ms>:

/* user implemented, get millisecond */
uint32_t isotp_user_get_ms(void){
	return millis();
 362:	d4 cf       	rjmp	.-88     	; 0x30c <millis>

00000364 <isotp_send_flow_control.isra.3.constprop.5>:
int isotp_receive(IsoTpLink *link, uint8_t *payload, const uint16_t payload_size, uint16_t *out_size)
{
    uint16_t copylen;
    
    if (ISOTP_RECEIVE_STATUS_FULL != link->receive_status){
        return ISOTP_RET_NO_DATA;
 364:	cf 93       	push	r28
 366:	df 93       	push	r29
 368:	cd b7       	in	r28, 0x3d	; 61
 36a:	de b7       	in	r29, 0x3e	; 62
 36c:	28 97       	sbiw	r28, 0x08	; 8
 36e:	0f b6       	in	r0, 0x3f	; 63
 370:	f8 94       	cli
 372:	de bf       	out	0x3e, r29	; 62
 374:	0f be       	out	0x3f, r0	; 63
 376:	cd bf       	out	0x3d, r28	; 61
 378:	62 95       	swap	r22
 37a:	60 7f       	andi	r22, 0xF0	; 240
 37c:	63 60       	ori	r22, 0x03	; 3
 37e:	69 83       	std	Y+1, r22	; 0x01
 380:	4a 83       	std	Y+2, r20	; 0x02
 382:	1b 82       	std	Y+3, r1	; 0x03
 384:	fe 01       	movw	r30, r28
 386:	34 96       	adiw	r30, 0x04	; 4
 388:	25 e0       	ldi	r18, 0x05	; 5
 38a:	df 01       	movw	r26, r30
 38c:	1d 92       	st	X+, r1
 38e:	2a 95       	dec	r18
 390:	e9 f7       	brne	.-6      	; 0x38c <isotp_send_flow_control.isra.3.constprop.5+0x28>
 392:	fc 01       	movw	r30, r24
 394:	60 81       	ld	r22, Z
 396:	71 81       	ldd	r23, Z+1	; 0x01
 398:	82 81       	ldd	r24, Z+2	; 0x02
 39a:	93 81       	ldd	r25, Z+3	; 0x03
 39c:	28 e0       	ldi	r18, 0x08	; 8
 39e:	ae 01       	movw	r20, r28
 3a0:	4f 5f       	subi	r20, 0xFF	; 255
 3a2:	5f 4f       	sbci	r21, 0xFF	; 255
 3a4:	c5 df       	rcall	.-118    	; 0x330 <isotp_user_send_can>
 3a6:	28 96       	adiw	r28, 0x08	; 8
 3a8:	0f b6       	in	r0, 0x3f	; 63
 3aa:	f8 94       	cli
 3ac:	de bf       	out	0x3e, r29	; 62
 3ae:	0f be       	out	0x3f, r0	; 63
 3b0:	cd bf       	out	0x3d, r28	; 61
 3b2:	df 91       	pop	r29
 3b4:	cf 91       	pop	r28
 3b6:	08 95       	ret

000003b8 <isotp_send_with_id>:
 3b8:	8f 92       	push	r8
 3ba:	9f 92       	push	r9
 3bc:	af 92       	push	r10
 3be:	bf 92       	push	r11
 3c0:	ef 92       	push	r14
 3c2:	ff 92       	push	r15
 3c4:	0f 93       	push	r16
 3c6:	1f 93       	push	r17
 3c8:	cf 93       	push	r28
 3ca:	df 93       	push	r29
 3cc:	cd b7       	in	r28, 0x3d	; 61
 3ce:	de b7       	in	r29, 0x3e	; 62
 3d0:	28 97       	sbiw	r28, 0x08	; 8
 3d2:	0f b6       	in	r0, 0x3f	; 63
 3d4:	f8 94       	cli
 3d6:	de bf       	out	0x3e, r29	; 62
 3d8:	0f be       	out	0x3f, r0	; 63
 3da:	cd bf       	out	0x3d, r28	; 61
 3dc:	7c 01       	movw	r14, r24
 3de:	4a 01       	movw	r8, r20
 3e0:	5b 01       	movw	r10, r22
 3e2:	dc 01       	movw	r26, r24
 3e4:	16 96       	adiw	r26, 0x06	; 6
 3e6:	8d 91       	ld	r24, X+
 3e8:	9c 91       	ld	r25, X
 3ea:	17 97       	sbiw	r26, 0x07	; 7
 3ec:	80 17       	cp	r24, r16
 3ee:	91 07       	cpc	r25, r17
 3f0:	08 f4       	brcc	.+2      	; 0x3f4 <isotp_send_with_id+0x3c>
 3f2:	85 c0       	rjmp	.+266    	; 0x4fe <__LOCK_REGION_LENGTH__+0xfe>
 3f4:	f7 01       	movw	r30, r14
 3f6:	83 8d       	ldd	r24, Z+27	; 0x1b
 3f8:	81 30       	cpi	r24, 0x01	; 1
 3fa:	09 f4       	brne	.+2      	; 0x3fe <isotp_send_with_id+0x46>
 3fc:	8a c0       	rjmp	.+276    	; 0x512 <__LOCK_REGION_LENGTH__+0x112>
 3fe:	11 87       	std	Z+9, r17	; 0x09
 400:	00 87       	std	Z+8, r16	; 0x08
 402:	13 86       	std	Z+11, r1	; 0x0b
 404:	12 86       	std	Z+10, r1	; 0x0a
 406:	a8 01       	movw	r20, r16
 408:	b9 01       	movw	r22, r18
 40a:	84 81       	ldd	r24, Z+4	; 0x04
 40c:	95 81       	ldd	r25, Z+5	; 0x05
 40e:	97 d4       	rcall	.+2350   	; 0xd3e <memcpy>
 410:	f7 01       	movw	r30, r14
 412:	00 85       	ldd	r16, Z+8	; 0x08
 414:	11 85       	ldd	r17, Z+9	; 0x09
 416:	08 30       	cpi	r16, 0x08	; 8
 418:	11 05       	cpc	r17, r1
 41a:	08 f4       	brcc	.+2      	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
 41c:	51 c0       	rjmp	.+162    	; 0x4c0 <__LOCK_REGION_LENGTH__+0xc0>
 41e:	0a 83       	std	Y+2, r16	; 0x02
 420:	81 2f       	mov	r24, r17
 422:	82 95       	swap	r24
 424:	80 7f       	andi	r24, 0xF0	; 240
 426:	81 60       	ori	r24, 0x01	; 1
 428:	89 83       	std	Y+1, r24	; 0x01
 42a:	04 80       	ldd	r0, Z+4	; 0x04
 42c:	f5 81       	ldd	r31, Z+5	; 0x05
 42e:	e0 2d       	mov	r30, r0
 430:	86 e0       	ldi	r24, 0x06	; 6
 432:	de 01       	movw	r26, r28
 434:	13 96       	adiw	r26, 0x03	; 3
 436:	01 90       	ld	r0, Z+
 438:	0d 92       	st	X+, r0
 43a:	8a 95       	dec	r24
 43c:	e1 f7       	brne	.-8      	; 0x436 <__LOCK_REGION_LENGTH__+0x36>
 43e:	28 e0       	ldi	r18, 0x08	; 8
 440:	ae 01       	movw	r20, r28
 442:	4f 5f       	subi	r20, 0xFF	; 255
 444:	5f 4f       	sbci	r21, 0xFF	; 255
 446:	c5 01       	movw	r24, r10
 448:	b4 01       	movw	r22, r8
 44a:	72 df       	rcall	.-284    	; 0x330 <isotp_user_send_can>
 44c:	00 97       	sbiw	r24, 0x00	; 0
 44e:	39 f5       	brne	.+78     	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
 450:	f7 01       	movw	r30, r14
 452:	82 85       	ldd	r24, Z+10	; 0x0a
 454:	93 85       	ldd	r25, Z+11	; 0x0b
 456:	06 96       	adiw	r24, 0x06	; 6
 458:	93 87       	std	Z+11, r25	; 0x0b
 45a:	82 87       	std	Z+10, r24	; 0x0a
 45c:	11 e0       	ldi	r17, 0x01	; 1
 45e:	14 87       	std	Z+12, r17	; 0x0c
 460:	85 e0       	ldi	r24, 0x05	; 5
 462:	90 e0       	ldi	r25, 0x00	; 0
 464:	96 87       	std	Z+14, r25	; 0x0e
 466:	85 87       	std	Z+13, r24	; 0x0d
 468:	17 86       	std	Z+15, r1	; 0x0f
 46a:	10 8a       	std	Z+16, r1	; 0x10
 46c:	7a df       	rcall	.-268    	; 0x362 <isotp_user_get_ms>
 46e:	d7 01       	movw	r26, r14
 470:	51 96       	adiw	r26, 0x11	; 17
 472:	6d 93       	st	X+, r22
 474:	7d 93       	st	X+, r23
 476:	8d 93       	st	X+, r24
 478:	9c 93       	st	X, r25
 47a:	54 97       	sbiw	r26, 0x14	; 20
 47c:	72 df       	rcall	.-284    	; 0x362 <isotp_user_get_ms>
 47e:	dc 01       	movw	r26, r24
 480:	cb 01       	movw	r24, r22
 482:	8c 59       	subi	r24, 0x9C	; 156
 484:	9f 4f       	sbci	r25, 0xFF	; 255
 486:	af 4f       	sbci	r26, 0xFF	; 255
 488:	bf 4f       	sbci	r27, 0xFF	; 255
 48a:	f7 01       	movw	r30, r14
 48c:	85 8b       	std	Z+21, r24	; 0x15
 48e:	96 8b       	std	Z+22, r25	; 0x16
 490:	a7 8b       	std	Z+23, r26	; 0x17
 492:	b0 8f       	std	Z+24, r27	; 0x18
 494:	12 8e       	std	Z+26, r1	; 0x1a
 496:	11 8e       	std	Z+25, r1	; 0x19
 498:	13 8f       	std	Z+27, r17	; 0x1b
 49a:	80 e0       	ldi	r24, 0x00	; 0
 49c:	90 e0       	ldi	r25, 0x00	; 0
 49e:	28 96       	adiw	r28, 0x08	; 8
 4a0:	0f b6       	in	r0, 0x3f	; 63
 4a2:	f8 94       	cli
 4a4:	de bf       	out	0x3e, r29	; 62
 4a6:	0f be       	out	0x3f, r0	; 63
 4a8:	cd bf       	out	0x3d, r28	; 61
 4aa:	df 91       	pop	r29
 4ac:	cf 91       	pop	r28
 4ae:	1f 91       	pop	r17
 4b0:	0f 91       	pop	r16
 4b2:	ff 90       	pop	r15
 4b4:	ef 90       	pop	r14
 4b6:	bf 90       	pop	r11
 4b8:	af 90       	pop	r10
 4ba:	9f 90       	pop	r9
 4bc:	8f 90       	pop	r8
 4be:	08 95       	ret
 4c0:	64 81       	ldd	r22, Z+4	; 0x04
 4c2:	75 81       	ldd	r23, Z+5	; 0x05
 4c4:	80 2f       	mov	r24, r16
 4c6:	82 95       	swap	r24
 4c8:	80 7f       	andi	r24, 0xF0	; 240
 4ca:	89 83       	std	Y+1, r24	; 0x01
 4cc:	a8 01       	movw	r20, r16
 4ce:	ce 01       	movw	r24, r28
 4d0:	02 96       	adiw	r24, 0x02	; 2
 4d2:	35 d4       	rcall	.+2154   	; 0xd3e <memcpy>
 4d4:	47 e0       	ldi	r20, 0x07	; 7
 4d6:	50 e0       	ldi	r21, 0x00	; 0
 4d8:	40 1b       	sub	r20, r16
 4da:	51 0b       	sbc	r21, r17
 4dc:	60 e0       	ldi	r22, 0x00	; 0
 4de:	70 e0       	ldi	r23, 0x00	; 0
 4e0:	82 e0       	ldi	r24, 0x02	; 2
 4e2:	90 e0       	ldi	r25, 0x00	; 0
 4e4:	8c 0f       	add	r24, r28
 4e6:	9d 1f       	adc	r25, r29
 4e8:	80 0f       	add	r24, r16
 4ea:	91 1f       	adc	r25, r17
 4ec:	31 d4       	rcall	.+2146   	; 0xd50 <memset>
 4ee:	28 e0       	ldi	r18, 0x08	; 8
 4f0:	ae 01       	movw	r20, r28
 4f2:	4f 5f       	subi	r20, 0xFF	; 255
 4f4:	5f 4f       	sbci	r21, 0xFF	; 255
 4f6:	c5 01       	movw	r24, r10
 4f8:	b4 01       	movw	r22, r8
 4fa:	1a df       	rcall	.-460    	; 0x330 <isotp_user_send_can>
 4fc:	d0 cf       	rjmp	.-96     	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
 4fe:	8d e0       	ldi	r24, 0x0D	; 13
 500:	91 e0       	ldi	r25, 0x01	; 1
 502:	9f 93       	push	r25
 504:	8f 93       	push	r24
 506:	13 df       	rcall	.-474    	; 0x32e <isotp_user_debug>
 508:	0f 90       	pop	r0
 50a:	0f 90       	pop	r0
 50c:	8d ef       	ldi	r24, 0xFD	; 253
 50e:	9f ef       	ldi	r25, 0xFF	; 255
 510:	c6 cf       	rjmp	.-116    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>
 512:	86 e5       	ldi	r24, 0x56	; 86
 514:	91 e0       	ldi	r25, 0x01	; 1
 516:	9f 93       	push	r25
 518:	8f 93       	push	r24
 51a:	09 df       	rcall	.-494    	; 0x32e <isotp_user_debug>
 51c:	0f 90       	pop	r0
 51e:	0f 90       	pop	r0
 520:	8e ef       	ldi	r24, 0xFE	; 254
 522:	9f ef       	ldi	r25, 0xFF	; 255
 524:	bc cf       	rjmp	.-136    	; 0x49e <__LOCK_REGION_LENGTH__+0x9e>

00000526 <isotp_send>:
 526:	0f 93       	push	r16
 528:	1f 93       	push	r17
 52a:	9b 01       	movw	r18, r22
 52c:	8a 01       	movw	r16, r20
 52e:	fc 01       	movw	r30, r24
 530:	40 81       	ld	r20, Z
 532:	51 81       	ldd	r21, Z+1	; 0x01
 534:	62 81       	ldd	r22, Z+2	; 0x02
 536:	73 81       	ldd	r23, Z+3	; 0x03
 538:	3f df       	rcall	.-386    	; 0x3b8 <isotp_send_with_id>
 53a:	1f 91       	pop	r17
 53c:	0f 91       	pop	r16
 53e:	08 95       	ret

00000540 <isotp_on_can_message>:
 540:	cf 92       	push	r12
 542:	df 92       	push	r13
 544:	ef 92       	push	r14
 546:	ff 92       	push	r15
 548:	0f 93       	push	r16
 54a:	1f 93       	push	r17
 54c:	cf 93       	push	r28
 54e:	df 93       	push	r29
 550:	cd b7       	in	r28, 0x3d	; 61
 552:	de b7       	in	r29, 0x3e	; 62
 554:	28 97       	sbiw	r28, 0x08	; 8
 556:	0f b6       	in	r0, 0x3f	; 63
 558:	f8 94       	cli
 55a:	de bf       	out	0x3e, r29	; 62
 55c:	0f be       	out	0x3f, r0	; 63
 55e:	cd bf       	out	0x3d, r28	; 61
 560:	7c 01       	movw	r14, r24
 562:	9e ef       	ldi	r25, 0xFE	; 254
 564:	94 0f       	add	r25, r20
 566:	97 30       	cpi	r25, 0x07	; 7
 568:	78 f0       	brcs	.+30     	; 0x588 <isotp_on_can_message+0x48>
 56a:	28 96       	adiw	r28, 0x08	; 8
 56c:	0f b6       	in	r0, 0x3f	; 63
 56e:	f8 94       	cli
 570:	de bf       	out	0x3e, r29	; 62
 572:	0f be       	out	0x3f, r0	; 63
 574:	cd bf       	out	0x3d, r28	; 61
 576:	df 91       	pop	r29
 578:	cf 91       	pop	r28
 57a:	1f 91       	pop	r17
 57c:	0f 91       	pop	r16
 57e:	ff 90       	pop	r15
 580:	ef 90       	pop	r14
 582:	df 90       	pop	r13
 584:	cf 90       	pop	r12
 586:	08 95       	ret
 588:	14 2f       	mov	r17, r20
 58a:	c4 2e       	mov	r12, r20
 58c:	d1 2c       	mov	r13, r1
 58e:	a6 01       	movw	r20, r12
 590:	ce 01       	movw	r24, r28
 592:	01 96       	adiw	r24, 0x01	; 1
 594:	d4 d3       	rcall	.+1960   	; 0xd3e <memcpy>
 596:	48 e0       	ldi	r20, 0x08	; 8
 598:	50 e0       	ldi	r21, 0x00	; 0
 59a:	4c 19       	sub	r20, r12
 59c:	5d 09       	sbc	r21, r13
 59e:	60 e0       	ldi	r22, 0x00	; 0
 5a0:	70 e0       	ldi	r23, 0x00	; 0
 5a2:	81 e0       	ldi	r24, 0x01	; 1
 5a4:	90 e0       	ldi	r25, 0x00	; 0
 5a6:	8c 0f       	add	r24, r28
 5a8:	9d 1f       	adc	r25, r29
 5aa:	8c 0d       	add	r24, r12
 5ac:	9d 1d       	adc	r25, r13
 5ae:	d0 d3       	rcall	.+1952   	; 0xd50 <memset>
 5b0:	89 81       	ldd	r24, Y+1	; 0x01
 5b2:	98 2f       	mov	r25, r24
 5b4:	9f 70       	andi	r25, 0x0F	; 15
 5b6:	91 30       	cpi	r25, 0x01	; 1
 5b8:	09 f4       	brne	.+2      	; 0x5bc <isotp_on_can_message+0x7c>
 5ba:	66 c0       	rjmp	.+204    	; 0x688 <isotp_on_can_message+0x148>
 5bc:	08 f4       	brcc	.+2      	; 0x5c0 <isotp_on_can_message+0x80>
 5be:	3f c0       	rjmp	.+126    	; 0x63e <isotp_on_can_message+0xfe>
 5c0:	92 30       	cpi	r25, 0x02	; 2
 5c2:	99 f1       	breq	.+102    	; 0x62a <isotp_on_can_message+0xea>
 5c4:	93 30       	cpi	r25, 0x03	; 3
 5c6:	89 f6       	brne	.-94     	; 0x56a <isotp_on_can_message+0x2a>
 5c8:	f7 01       	movw	r30, r14
 5ca:	83 8d       	ldd	r24, Z+27	; 0x1b
 5cc:	81 30       	cpi	r24, 0x01	; 1
 5ce:	69 f6       	brne	.-102    	; 0x56a <isotp_on_can_message+0x2a>
 5d0:	12 30       	cpi	r17, 0x02	; 2
 5d2:	09 f4       	brne	.+2      	; 0x5d6 <isotp_on_can_message+0x96>
 5d4:	e4 c0       	rjmp	.+456    	; 0x79e <isotp_on_can_message+0x25e>
 5d6:	c5 de       	rcall	.-630    	; 0x362 <isotp_user_get_ms>
 5d8:	dc 01       	movw	r26, r24
 5da:	cb 01       	movw	r24, r22
 5dc:	8c 59       	subi	r24, 0x9C	; 156
 5de:	9f 4f       	sbci	r25, 0xFF	; 255
 5e0:	af 4f       	sbci	r26, 0xFF	; 255
 5e2:	bf 4f       	sbci	r27, 0xFF	; 255
 5e4:	f7 01       	movw	r30, r14
 5e6:	85 8b       	std	Z+21, r24	; 0x15
 5e8:	96 8b       	std	Z+22, r25	; 0x16
 5ea:	a7 8b       	std	Z+23, r26	; 0x17
 5ec:	b0 8f       	std	Z+24, r27	; 0x18
 5ee:	89 81       	ldd	r24, Y+1	; 0x01
 5f0:	80 7f       	andi	r24, 0xF0	; 240
 5f2:	80 32       	cpi	r24, 0x20	; 32
 5f4:	09 f4       	brne	.+2      	; 0x5f8 <isotp_on_can_message+0xb8>
 5f6:	03 c1       	rjmp	.+518    	; 0x7fe <isotp_on_can_message+0x2be>
 5f8:	80 31       	cpi	r24, 0x10	; 16
 5fa:	09 f4       	brne	.+2      	; 0x5fe <isotp_on_can_message+0xbe>
 5fc:	f2 c0       	rjmp	.+484    	; 0x7e2 <isotp_on_can_message+0x2a2>
 5fe:	81 11       	cpse	r24, r1
 600:	b4 cf       	rjmp	.-152    	; 0x56a <isotp_on_can_message+0x2a>
 602:	8a 81       	ldd	r24, Y+2	; 0x02
 604:	81 11       	cpse	r24, r1
 606:	03 c1       	rjmp	.+518    	; 0x80e <isotp_on_can_message+0x2ce>
 608:	8f ef       	ldi	r24, 0xFF	; 255
 60a:	9f ef       	ldi	r25, 0xFF	; 255
 60c:	f7 01       	movw	r30, r14
 60e:	96 87       	std	Z+14, r25	; 0x0e
 610:	85 87       	std	Z+13, r24	; 0x0d
 612:	8b 81       	ldd	r24, Y+3	; 0x03
 614:	9f e0       	ldi	r25, 0x0F	; 15
 616:	98 0f       	add	r25, r24
 618:	99 30       	cpi	r25, 0x09	; 9
 61a:	08 f4       	brcc	.+2      	; 0x61e <isotp_on_can_message+0xde>
 61c:	fd c0       	rjmp	.+506    	; 0x818 <isotp_on_can_message+0x2d8>
 61e:	87 fd       	sbrc	r24, 7
 620:	11 c1       	rjmp	.+546    	; 0x844 <isotp_on_can_message+0x304>
 622:	f7 01       	movw	r30, r14
 624:	87 87       	std	Z+15, r24	; 0x0f
 626:	10 8a       	std	Z+16, r1	; 0x10
 628:	a0 cf       	rjmp	.-192    	; 0x56a <isotp_on_can_message+0x2a>
 62a:	f7 01       	movw	r30, r14
 62c:	90 a9       	ldd	r25, Z+48	; 0x30
 62e:	91 30       	cpi	r25, 0x01	; 1
 630:	09 f4       	brne	.+2      	; 0x634 <isotp_on_can_message+0xf4>
 632:	6c c0       	rjmp	.+216    	; 0x70c <isotp_on_can_message+0x1cc>
 634:	8a ef       	ldi	r24, 0xFA	; 250
 636:	9f ef       	ldi	r25, 0xFF	; 255
 638:	97 a7       	std	Z+47, r25	; 0x2f
 63a:	86 a7       	std	Z+46, r24	; 0x2e
 63c:	96 cf       	rjmp	.-212    	; 0x56a <isotp_on_can_message+0x2a>
 63e:	f7 01       	movw	r30, r14
 640:	90 a9       	ldd	r25, Z+48	; 0x30
 642:	91 30       	cpi	r25, 0x01	; 1
 644:	09 f4       	brne	.+2      	; 0x648 <isotp_on_can_message+0x108>
 646:	5d c0       	rjmp	.+186    	; 0x702 <isotp_on_can_message+0x1c2>
 648:	f7 01       	movw	r30, r14
 64a:	17 a6       	std	Z+47, r1	; 0x2f
 64c:	16 a6       	std	Z+46, r1	; 0x2e
 64e:	98 2f       	mov	r25, r24
 650:	90 7f       	andi	r25, 0xF0	; 240
 652:	09 f4       	brne	.+2      	; 0x656 <isotp_on_can_message+0x116>
 654:	ac c0       	rjmp	.+344    	; 0x7ae <isotp_on_can_message+0x26e>
 656:	82 95       	swap	r24
 658:	8f 70       	andi	r24, 0x0F	; 15
 65a:	48 2f       	mov	r20, r24
 65c:	50 e0       	ldi	r21, 0x00	; 0
 65e:	4c 15       	cp	r20, r12
 660:	5d 05       	cpc	r21, r13
 662:	0c f0       	brlt	.+2      	; 0x666 <isotp_on_can_message+0x126>
 664:	a4 c0       	rjmp	.+328    	; 0x7ae <isotp_on_can_message+0x26e>
 666:	be 01       	movw	r22, r28
 668:	6e 5f       	subi	r22, 0xFE	; 254
 66a:	7f 4f       	sbci	r23, 0xFF	; 255
 66c:	f7 01       	movw	r30, r14
 66e:	80 a1       	ldd	r24, Z+32	; 0x20
 670:	91 a1       	ldd	r25, Z+33	; 0x21
 672:	65 d3       	rcall	.+1738   	; 0xd3e <memcpy>
 674:	89 81       	ldd	r24, Y+1	; 0x01
 676:	82 95       	swap	r24
 678:	8f 70       	andi	r24, 0x0F	; 15
 67a:	90 e0       	ldi	r25, 0x00	; 0
 67c:	f7 01       	movw	r30, r14
 67e:	95 a3       	std	Z+37, r25	; 0x25
 680:	84 a3       	std	Z+36, r24	; 0x24
 682:	82 e0       	ldi	r24, 0x02	; 2
 684:	80 ab       	std	Z+48, r24	; 0x30
 686:	71 cf       	rjmp	.-286    	; 0x56a <isotp_on_can_message+0x2a>
 688:	f7 01       	movw	r30, r14
 68a:	90 a9       	ldd	r25, Z+48	; 0x30
 68c:	91 30       	cpi	r25, 0x01	; 1
 68e:	a1 f1       	breq	.+104    	; 0x6f8 <isotp_on_can_message+0x1b8>
 690:	f7 01       	movw	r30, r14
 692:	17 a6       	std	Z+47, r1	; 0x2f
 694:	16 a6       	std	Z+46, r1	; 0x2e
 696:	18 30       	cpi	r17, 0x08	; 8
 698:	09 f0       	breq	.+2      	; 0x69c <isotp_on_can_message+0x15c>
 69a:	91 c0       	rjmp	.+290    	; 0x7be <isotp_on_can_message+0x27e>
 69c:	82 95       	swap	r24
 69e:	8f 70       	andi	r24, 0x0F	; 15
 6a0:	90 e0       	ldi	r25, 0x00	; 0
 6a2:	98 2f       	mov	r25, r24
 6a4:	88 27       	eor	r24, r24
 6a6:	2a 81       	ldd	r18, Y+2	; 0x02
 6a8:	82 0f       	add	r24, r18
 6aa:	91 1d       	adc	r25, r1
 6ac:	f7 01       	movw	r30, r14
 6ae:	a0 a1       	ldd	r26, Z+32	; 0x20
 6b0:	b1 a1       	ldd	r27, Z+33	; 0x21
 6b2:	26 e0       	ldi	r18, 0x06	; 6
 6b4:	fe 01       	movw	r30, r28
 6b6:	33 96       	adiw	r30, 0x03	; 3
 6b8:	01 90       	ld	r0, Z+
 6ba:	0d 92       	st	X+, r0
 6bc:	2a 95       	dec	r18
 6be:	e1 f7       	brne	.-8      	; 0x6b8 <isotp_on_can_message+0x178>
 6c0:	f7 01       	movw	r30, r14
 6c2:	95 a3       	std	Z+37, r25	; 0x25
 6c4:	84 a3       	std	Z+36, r24	; 0x24
 6c6:	86 e0       	ldi	r24, 0x06	; 6
 6c8:	90 e0       	ldi	r25, 0x00	; 0
 6ca:	97 a3       	std	Z+39, r25	; 0x27
 6cc:	86 a3       	std	Z+38, r24	; 0x26
 6ce:	81 e0       	ldi	r24, 0x01	; 1
 6d0:	80 a7       	std	Z+40, r24	; 0x28
 6d2:	80 ab       	std	Z+48, r24	; 0x30
 6d4:	11 a7       	std	Z+41, r17	; 0x29
 6d6:	48 e0       	ldi	r20, 0x08	; 8
 6d8:	60 e0       	ldi	r22, 0x00	; 0
 6da:	c7 01       	movw	r24, r14
 6dc:	43 de       	rcall	.-890    	; 0x364 <isotp_send_flow_control.isra.3.constprop.5>
 6de:	41 de       	rcall	.-894    	; 0x362 <isotp_user_get_ms>
 6e0:	dc 01       	movw	r26, r24
 6e2:	cb 01       	movw	r24, r22
 6e4:	8c 59       	subi	r24, 0x9C	; 156
 6e6:	9f 4f       	sbci	r25, 0xFF	; 255
 6e8:	af 4f       	sbci	r26, 0xFF	; 255
 6ea:	bf 4f       	sbci	r27, 0xFF	; 255
 6ec:	f7 01       	movw	r30, r14
 6ee:	82 a7       	std	Z+42, r24	; 0x2a
 6f0:	93 a7       	std	Z+43, r25	; 0x2b
 6f2:	a4 a7       	std	Z+44, r26	; 0x2c
 6f4:	b5 a7       	std	Z+45, r27	; 0x2d
 6f6:	39 cf       	rjmp	.-398    	; 0x56a <isotp_on_can_message+0x2a>
 6f8:	2a ef       	ldi	r18, 0xFA	; 250
 6fa:	3f ef       	ldi	r19, 0xFF	; 255
 6fc:	37 a7       	std	Z+47, r19	; 0x2f
 6fe:	26 a7       	std	Z+46, r18	; 0x2e
 700:	ca cf       	rjmp	.-108    	; 0x696 <isotp_on_can_message+0x156>
 702:	2a ef       	ldi	r18, 0xFA	; 250
 704:	3f ef       	ldi	r19, 0xFF	; 255
 706:	37 a7       	std	Z+47, r19	; 0x2f
 708:	26 a7       	std	Z+46, r18	; 0x2e
 70a:	a1 cf       	rjmp	.-190    	; 0x64e <isotp_on_can_message+0x10e>
 70c:	82 95       	swap	r24
 70e:	8f 70       	andi	r24, 0x0F	; 15
 710:	f7 01       	movw	r30, r14
 712:	90 a5       	ldd	r25, Z+40	; 0x28
 714:	98 13       	cpse	r25, r24
 716:	5e c0       	rjmp	.+188    	; 0x7d4 <isotp_on_can_message+0x294>
 718:	86 a1       	ldd	r24, Z+38	; 0x26
 71a:	97 a1       	ldd	r25, Z+39	; 0x27
 71c:	04 a1       	ldd	r16, Z+36	; 0x24
 71e:	15 a1       	ldd	r17, Z+37	; 0x25
 720:	08 1b       	sub	r16, r24
 722:	19 0b       	sbc	r17, r25
 724:	08 30       	cpi	r16, 0x08	; 8
 726:	11 05       	cpc	r17, r1
 728:	10 f0       	brcs	.+4      	; 0x72e <isotp_on_can_message+0x1ee>
 72a:	07 e0       	ldi	r16, 0x07	; 7
 72c:	10 e0       	ldi	r17, 0x00	; 0
 72e:	f1 e0       	ldi	r31, 0x01	; 1
 730:	cf 1a       	sub	r12, r31
 732:	d1 08       	sbc	r13, r1
 734:	c0 16       	cp	r12, r16
 736:	d1 06       	cpc	r13, r17
 738:	08 f4       	brcc	.+2      	; 0x73c <isotp_on_can_message+0x1fc>
 73a:	7c c0       	rjmp	.+248    	; 0x834 <isotp_on_can_message+0x2f4>
 73c:	f7 01       	movw	r30, r14
 73e:	20 a1       	ldd	r18, Z+32	; 0x20
 740:	31 a1       	ldd	r19, Z+33	; 0x21
 742:	a8 01       	movw	r20, r16
 744:	be 01       	movw	r22, r28
 746:	6e 5f       	subi	r22, 0xFE	; 254
 748:	7f 4f       	sbci	r23, 0xFF	; 255
 74a:	82 0f       	add	r24, r18
 74c:	93 1f       	adc	r25, r19
 74e:	f7 d2       	rcall	.+1518   	; 0xd3e <memcpy>
 750:	f7 01       	movw	r30, r14
 752:	86 a1       	ldd	r24, Z+38	; 0x26
 754:	97 a1       	ldd	r25, Z+39	; 0x27
 756:	08 0f       	add	r16, r24
 758:	19 1f       	adc	r17, r25
 75a:	17 a3       	std	Z+39, r17	; 0x27
 75c:	06 a3       	std	Z+38, r16	; 0x26
 75e:	80 a5       	ldd	r24, Z+40	; 0x28
 760:	8f 5f       	subi	r24, 0xFF	; 255
 762:	80 31       	cpi	r24, 0x10	; 16
 764:	a0 f1       	brcs	.+104    	; 0x7ce <isotp_on_can_message+0x28e>
 766:	10 a6       	std	Z+40, r1	; 0x28
 768:	fc dd       	rcall	.-1032   	; 0x362 <isotp_user_get_ms>
 76a:	dc 01       	movw	r26, r24
 76c:	cb 01       	movw	r24, r22
 76e:	8c 59       	subi	r24, 0x9C	; 156
 770:	9f 4f       	sbci	r25, 0xFF	; 255
 772:	af 4f       	sbci	r26, 0xFF	; 255
 774:	bf 4f       	sbci	r27, 0xFF	; 255
 776:	f7 01       	movw	r30, r14
 778:	82 a7       	std	Z+42, r24	; 0x2a
 77a:	93 a7       	std	Z+43, r25	; 0x2b
 77c:	a4 a7       	std	Z+44, r26	; 0x2c
 77e:	b5 a7       	std	Z+45, r27	; 0x2d
 780:	26 a1       	ldd	r18, Z+38	; 0x26
 782:	37 a1       	ldd	r19, Z+39	; 0x27
 784:	84 a1       	ldd	r24, Z+36	; 0x24
 786:	95 a1       	ldd	r25, Z+37	; 0x25
 788:	28 17       	cp	r18, r24
 78a:	39 07       	cpc	r19, r25
 78c:	08 f0       	brcs	.+2      	; 0x790 <isotp_on_can_message+0x250>
 78e:	46 c0       	rjmp	.+140    	; 0x81c <isotp_on_can_message+0x2dc>
 790:	f7 01       	movw	r30, r14
 792:	81 a5       	ldd	r24, Z+41	; 0x29
 794:	81 50       	subi	r24, 0x01	; 1
 796:	09 f4       	brne	.+2      	; 0x79a <isotp_on_can_message+0x25a>
 798:	45 c0       	rjmp	.+138    	; 0x824 <isotp_on_can_message+0x2e4>
 79a:	81 a7       	std	Z+41, r24	; 0x29
 79c:	e6 ce       	rjmp	.-564    	; 0x56a <isotp_on_can_message+0x2a>
 79e:	8d ee       	ldi	r24, 0xED	; 237
 7a0:	91 e0       	ldi	r25, 0x01	; 1
 7a2:	9f 93       	push	r25
 7a4:	8f 93       	push	r24
 7a6:	c3 dd       	rcall	.-1146   	; 0x32e <isotp_user_debug>
 7a8:	0f 90       	pop	r0
 7aa:	0f 90       	pop	r0
 7ac:	de ce       	rjmp	.-580    	; 0x56a <isotp_on_can_message+0x2a>
 7ae:	8c e8       	ldi	r24, 0x8C	; 140
 7b0:	91 e0       	ldi	r25, 0x01	; 1
 7b2:	9f 93       	push	r25
 7b4:	8f 93       	push	r24
 7b6:	bb dd       	rcall	.-1162   	; 0x32e <isotp_user_debug>
 7b8:	0f 90       	pop	r0
 7ba:	0f 90       	pop	r0
 7bc:	d6 ce       	rjmp	.-596    	; 0x56a <isotp_on_can_message+0x2a>
 7be:	8b ea       	ldi	r24, 0xAB	; 171
 7c0:	91 e0       	ldi	r25, 0x01	; 1
 7c2:	9f 93       	push	r25
 7c4:	8f 93       	push	r24
 7c6:	b3 dd       	rcall	.-1178   	; 0x32e <isotp_user_debug>
 7c8:	0f 90       	pop	r0
 7ca:	0f 90       	pop	r0
 7cc:	ce ce       	rjmp	.-612    	; 0x56a <isotp_on_can_message+0x2a>
 7ce:	f7 01       	movw	r30, r14
 7d0:	80 a7       	std	Z+40, r24	; 0x28
 7d2:	ca cf       	rjmp	.-108    	; 0x768 <isotp_on_can_message+0x228>
 7d4:	8c ef       	ldi	r24, 0xFC	; 252
 7d6:	9f ef       	ldi	r25, 0xFF	; 255
 7d8:	f7 01       	movw	r30, r14
 7da:	97 a7       	std	Z+47, r25	; 0x2f
 7dc:	86 a7       	std	Z+46, r24	; 0x2e
 7de:	10 aa       	std	Z+48, r1	; 0x30
 7e0:	c4 ce       	rjmp	.-632    	; 0x56a <isotp_on_can_message+0x2a>
 7e2:	f7 01       	movw	r30, r14
 7e4:	80 89       	ldd	r24, Z+16	; 0x10
 7e6:	8f 5f       	subi	r24, 0xFF	; 255
 7e8:	80 8b       	std	Z+16, r24	; 0x10
 7ea:	82 30       	cpi	r24, 0x02	; 2
 7ec:	08 f4       	brcc	.+2      	; 0x7f0 <isotp_on_can_message+0x2b0>
 7ee:	bd ce       	rjmp	.-646    	; 0x56a <isotp_on_can_message+0x2a>
 7f0:	89 ef       	ldi	r24, 0xF9	; 249
 7f2:	9f ef       	ldi	r25, 0xFF	; 255
 7f4:	92 8f       	std	Z+26, r25	; 0x1a
 7f6:	81 8f       	std	Z+25, r24	; 0x19
 7f8:	82 e0       	ldi	r24, 0x02	; 2
 7fa:	83 8f       	std	Z+27, r24	; 0x1b
 7fc:	b6 ce       	rjmp	.-660    	; 0x56a <isotp_on_can_message+0x2a>
 7fe:	88 ef       	ldi	r24, 0xF8	; 248
 800:	9f ef       	ldi	r25, 0xFF	; 255
 802:	f7 01       	movw	r30, r14
 804:	92 8f       	std	Z+26, r25	; 0x1a
 806:	81 8f       	std	Z+25, r24	; 0x19
 808:	82 e0       	ldi	r24, 0x02	; 2
 80a:	83 8f       	std	Z+27, r24	; 0x1b
 80c:	ae ce       	rjmp	.-676    	; 0x56a <isotp_on_can_message+0x2a>
 80e:	90 e0       	ldi	r25, 0x00	; 0
 810:	f7 01       	movw	r30, r14
 812:	96 87       	std	Z+14, r25	; 0x0e
 814:	85 87       	std	Z+13, r24	; 0x0d
 816:	fd ce       	rjmp	.-518    	; 0x612 <isotp_on_can_message+0xd2>
 818:	81 e0       	ldi	r24, 0x01	; 1
 81a:	03 cf       	rjmp	.-506    	; 0x622 <isotp_on_can_message+0xe2>
 81c:	82 e0       	ldi	r24, 0x02	; 2
 81e:	f7 01       	movw	r30, r14
 820:	80 ab       	std	Z+48, r24	; 0x30
 822:	a3 ce       	rjmp	.-698    	; 0x56a <isotp_on_can_message+0x2a>
 824:	88 e0       	ldi	r24, 0x08	; 8
 826:	f7 01       	movw	r30, r14
 828:	81 a7       	std	Z+41, r24	; 0x29
 82a:	48 e0       	ldi	r20, 0x08	; 8
 82c:	60 e0       	ldi	r22, 0x00	; 0
 82e:	c7 01       	movw	r24, r14
 830:	99 dd       	rcall	.-1230   	; 0x364 <isotp_send_flow_control.isra.3.constprop.5>
 832:	9b ce       	rjmp	.-714    	; 0x56a <isotp_on_can_message+0x2a>
 834:	80 ed       	ldi	r24, 0xD0	; 208
 836:	91 e0       	ldi	r25, 0x01	; 1
 838:	9f 93       	push	r25
 83a:	8f 93       	push	r24
 83c:	78 dd       	rcall	.-1296   	; 0x32e <isotp_user_debug>
 83e:	0f 90       	pop	r0
 840:	0f 90       	pop	r0
 842:	93 ce       	rjmp	.-730    	; 0x56a <isotp_on_can_message+0x2a>
 844:	80 e0       	ldi	r24, 0x00	; 0
 846:	ed ce       	rjmp	.-550    	; 0x622 <isotp_on_can_message+0xe2>

00000848 <isotp_init_link>:
}

void isotp_init_link(IsoTpLink *link, uint32_t sendid, 
                     uint8_t *sendbuf, uint16_t sendbufsize,
                     uint8_t *recvbuf, uint16_t recvbufsize)
{
 848:	cf 92       	push	r12
 84a:	df 92       	push	r13
 84c:	ef 92       	push	r14
 84e:	ff 92       	push	r15
 850:	0f 93       	push	r16
 852:	1f 93       	push	r17
 854:	fc 01       	movw	r30, r24
    memset(link, 0, sizeof(*link));
 856:	81 e3       	ldi	r24, 0x31	; 49
 858:	df 01       	movw	r26, r30
 85a:	1d 92       	st	X+, r1
 85c:	8a 95       	dec	r24
 85e:	e9 f7       	brne	.-6      	; 0x85a <isotp_init_link+0x12>
    link->receive_status = ISOTP_RECEIVE_STATUS_IDLE;
 860:	10 aa       	std	Z+48, r1	; 0x30
    link->send_status = ISOTP_SEND_STATUS_IDLE;
 862:	13 8e       	std	Z+27, r1	; 0x1b
    link->send_arbitration_id = sendid;
 864:	40 83       	st	Z, r20
 866:	51 83       	std	Z+1, r21	; 0x01
 868:	62 83       	std	Z+2, r22	; 0x02
 86a:	73 83       	std	Z+3, r23	; 0x03
    link->send_buffer = sendbuf;
 86c:	35 83       	std	Z+5, r19	; 0x05
 86e:	24 83       	std	Z+4, r18	; 0x04
    link->send_buf_size = sendbufsize;
 870:	17 83       	std	Z+7, r17	; 0x07
 872:	06 83       	std	Z+6, r16	; 0x06
    link->receive_buffer = recvbuf;
 874:	f1 a2       	std	Z+33, r15	; 0x21
 876:	e0 a2       	std	Z+32, r14	; 0x20
    link->recevie_buf_size = recvbufsize;
 878:	d3 a2       	std	Z+35, r13	; 0x23
 87a:	c2 a2       	std	Z+34, r12	; 0x22
    
    return;
}
 87c:	1f 91       	pop	r17
 87e:	0f 91       	pop	r16
 880:	ff 90       	pop	r15
 882:	ef 90       	pop	r14
 884:	df 90       	pop	r13
 886:	cf 90       	pop	r12
 888:	08 95       	ret

0000088a <isotp_poll>:

void isotp_poll(IsoTpLink *link)
{
 88a:	cf 92       	push	r12
 88c:	df 92       	push	r13
 88e:	ef 92       	push	r14
 890:	ff 92       	push	r15
 892:	0f 93       	push	r16
 894:	1f 93       	push	r17
 896:	cf 93       	push	r28
 898:	df 93       	push	r29
 89a:	cd b7       	in	r28, 0x3d	; 61
 89c:	de b7       	in	r29, 0x3e	; 62
 89e:	28 97       	sbiw	r28, 0x08	; 8
 8a0:	0f b6       	in	r0, 0x3f	; 63
 8a2:	f8 94       	cli
 8a4:	de bf       	out	0x3e, r29	; 62
 8a6:	0f be       	out	0x3f, r0	; 63
 8a8:	cd bf       	out	0x3d, r28	; 61
 8aa:	8c 01       	movw	r16, r24
    int ret;

    /* only polling when operation in progress */
    if (ISOTP_SEND_STATUS_INPROGRESS == link->send_status){
 8ac:	fc 01       	movw	r30, r24
 8ae:	83 8d       	ldd	r24, Z+27	; 0x1b
 8b0:	81 30       	cpi	r24, 0x01	; 1
 8b2:	99 f0       	breq	.+38     	; 0x8da <isotp_poll+0x50>
            link->send_status = ISOTP_SEND_STATUS_ERROR;
        }
    }

    /* only polling when operation in progress */
    if (ISOTP_RECEIVE_STATUS_INPROGRESS == link->receive_status){
 8b4:	f8 01       	movw	r30, r16
 8b6:	80 a9       	ldd	r24, Z+48	; 0x30
 8b8:	81 30       	cpi	r24, 0x01	; 1
 8ba:	b1 f1       	breq	.+108    	; 0x928 <isotp_poll+0x9e>
            link->receive_status = ISOTP_RECEIVE_STATUS_IDLE;
        }
    }

    return;
}
 8bc:	28 96       	adiw	r28, 0x08	; 8
 8be:	0f b6       	in	r0, 0x3f	; 63
 8c0:	f8 94       	cli
 8c2:	de bf       	out	0x3e, r29	; 62
 8c4:	0f be       	out	0x3f, r0	; 63
 8c6:	cd bf       	out	0x3d, r28	; 61
 8c8:	df 91       	pop	r29
 8ca:	cf 91       	pop	r28
 8cc:	1f 91       	pop	r17
 8ce:	0f 91       	pop	r16
 8d0:	ff 90       	pop	r15
 8d2:	ef 90       	pop	r14
 8d4:	df 90       	pop	r13
 8d6:	cf 90       	pop	r12
 8d8:	08 95       	ret

    /* only polling when operation in progress */
    if (ISOTP_SEND_STATUS_INPROGRESS == link->send_status){

        /* continue send data */
        if (/* send data if bs_remain is invalid or bs_remain large than zero */
 8da:	85 85       	ldd	r24, Z+13	; 0x0d
 8dc:	96 85       	ldd	r25, Z+14	; 0x0e
 8de:	89 2b       	or	r24, r25
 8e0:	79 f0       	breq	.+30     	; 0x900 <isotp_poll+0x76>
            (ISOTP_INVALID_BS == link->send_bs_remain || link->send_bs_remain > 0) &&
 8e2:	87 85       	ldd	r24, Z+15	; 0x0f
 8e4:	88 23       	and	r24, r24
 8e6:	91 f1       	breq	.+100    	; 0x94c <isotp_poll+0xc2>
            /* and if st_min is zero or go beyond interval time */
            (0 == link->send_st_min || (0 != link->send_st_min && IsoTpTimeAfter(isotp_user_get_ms(), link->send_timer_st)))){
 8e8:	f8 01       	movw	r30, r16
 8ea:	c1 88       	ldd	r12, Z+17	; 0x11
 8ec:	d2 88       	ldd	r13, Z+18	; 0x12
 8ee:	e3 88       	ldd	r14, Z+19	; 0x13
 8f0:	f4 88       	ldd	r15, Z+20	; 0x14
 8f2:	37 dd       	rcall	.-1426   	; 0x362 <isotp_user_get_ms>
 8f4:	c6 1a       	sub	r12, r22
 8f6:	d7 0a       	sbc	r13, r23
 8f8:	e8 0a       	sbc	r14, r24
 8fa:	f9 0a       	sbc	r15, r25
 8fc:	f7 fc       	sbrc	r15, 7
 8fe:	26 c0       	rjmp	.+76     	; 0x94c <isotp_poll+0xc2>
                link->send_status = ISOTP_SEND_STATUS_ERROR;
            }
        }

        /* check timeout */
        if (IsoTpTimeAfter(isotp_user_get_ms(), link->send_timer_bs)){
 900:	f8 01       	movw	r30, r16
 902:	c5 88       	ldd	r12, Z+21	; 0x15
 904:	d6 88       	ldd	r13, Z+22	; 0x16
 906:	e7 88       	ldd	r14, Z+23	; 0x17
 908:	f0 8c       	ldd	r15, Z+24	; 0x18
 90a:	2b dd       	rcall	.-1450   	; 0x362 <isotp_user_get_ms>
 90c:	c6 1a       	sub	r12, r22
 90e:	d7 0a       	sbc	r13, r23
 910:	e8 0a       	sbc	r14, r24
 912:	f9 0a       	sbc	r15, r25
 914:	f7 fe       	sbrs	r15, 7
 916:	ce cf       	rjmp	.-100    	; 0x8b4 <isotp_poll+0x2a>
            link->send_protocol_resault = ISOTP_PROTOCOL_RESAULT_TIMEOUT_BS;
 918:	8e ef       	ldi	r24, 0xFE	; 254
 91a:	9f ef       	ldi	r25, 0xFF	; 255
 91c:	f8 01       	movw	r30, r16
 91e:	92 8f       	std	Z+26, r25	; 0x1a
 920:	81 8f       	std	Z+25, r24	; 0x19
            link->send_status = ISOTP_SEND_STATUS_ERROR;
 922:	82 e0       	ldi	r24, 0x02	; 2
 924:	83 8f       	std	Z+27, r24	; 0x1b
 926:	c6 cf       	rjmp	.-116    	; 0x8b4 <isotp_poll+0x2a>

    /* only polling when operation in progress */
    if (ISOTP_RECEIVE_STATUS_INPROGRESS == link->receive_status){
        
        /* check timeout */
        if (IsoTpTimeAfter(isotp_user_get_ms(), link->receive_timer_cr)){
 928:	c2 a4       	ldd	r12, Z+42	; 0x2a
 92a:	d3 a4       	ldd	r13, Z+43	; 0x2b
 92c:	e4 a4       	ldd	r14, Z+44	; 0x2c
 92e:	f5 a4       	ldd	r15, Z+45	; 0x2d
 930:	18 dd       	rcall	.-1488   	; 0x362 <isotp_user_get_ms>
 932:	c6 1a       	sub	r12, r22
 934:	d7 0a       	sbc	r13, r23
 936:	e8 0a       	sbc	r14, r24
 938:	f9 0a       	sbc	r15, r25
 93a:	f7 fe       	sbrs	r15, 7
 93c:	bf cf       	rjmp	.-130    	; 0x8bc <isotp_poll+0x32>
            link->receive_protocol_resault = ISOTP_PROTOCOL_RESAULT_TIMEOUT_CR;
 93e:	8d ef       	ldi	r24, 0xFD	; 253
 940:	9f ef       	ldi	r25, 0xFF	; 255
 942:	f8 01       	movw	r30, r16
 944:	97 a7       	std	Z+47, r25	; 0x2f
 946:	86 a7       	std	Z+46, r24	; 0x2e
            link->receive_status = ISOTP_RECEIVE_STATUS_IDLE;
 948:	10 aa       	std	Z+48, r1	; 0x30
        }
    }

    return;
 94a:	b8 cf       	rjmp	.-144    	; 0x8bc <isotp_poll+0x32>
	IsoTpCanMessage message;
    uint8_t data_length;
    int ret;

    /* multi frame message length must greater than 7  */
    assert(link->send_size > 7);
 94c:	f8 01       	movw	r30, r16
 94e:	e0 84       	ldd	r14, Z+8	; 0x08
 950:	f1 84       	ldd	r15, Z+9	; 0x09
 952:	f8 e0       	ldi	r31, 0x08	; 8
 954:	ef 16       	cp	r14, r31
 956:	f1 04       	cpc	r15, r1
 958:	08 f4       	brcc	.+2      	; 0x95c <isotp_poll+0xd2>
 95a:	72 c0       	rjmp	.+228    	; 0xa40 <isotp_poll+0x1b6>

    /* setup message  */
    message.as.consecutive_frame.type = TSOTP_PCI_TYPE_CONSECUTIVE_FRAME;
    message.as.consecutive_frame.SN = link->send_sn;
 95c:	f8 01       	movw	r30, r16
 95e:	84 85       	ldd	r24, Z+12	; 0x0c
 960:	82 95       	swap	r24
 962:	80 7f       	andi	r24, 0xF0	; 240
 964:	82 60       	ori	r24, 0x02	; 2
 966:	89 83       	std	Y+1, r24	; 0x01
    data_length = link->send_size - link->send_offset;
 968:	22 85       	ldd	r18, Z+10	; 0x0a
 96a:	33 85       	ldd	r19, Z+11	; 0x0b
 96c:	8e 2d       	mov	r24, r14
 96e:	82 1b       	sub	r24, r18
    if (data_length > sizeof(message.as.consecutive_frame.data)){
        data_length = sizeof(message.as.consecutive_frame.data);
    }
    (void)memcpy(message.as.consecutive_frame.data, link->send_buffer + link->send_offset, data_length);
 970:	88 30       	cpi	r24, 0x08	; 8
 972:	08 f0       	brcs	.+2      	; 0x976 <isotp_poll+0xec>
 974:	87 e0       	ldi	r24, 0x07	; 7
 976:	e8 2e       	mov	r14, r24
 978:	f1 2c       	mov	r15, r1
 97a:	f8 01       	movw	r30, r16
 97c:	64 81       	ldd	r22, Z+4	; 0x04
 97e:	75 81       	ldd	r23, Z+5	; 0x05
 980:	62 0f       	add	r22, r18
 982:	73 1f       	adc	r23, r19
 984:	a7 01       	movw	r20, r14
 986:	ce 01       	movw	r24, r28
 988:	02 96       	adiw	r24, 0x02	; 2
 98a:	d9 d1       	rcall	.+946    	; 0xd3e <memcpy>

    /* send message */
#ifdef ISO_TP_FRAME_PADDING
    (void)memset(message.as.consecutive_frame.data + data_length,
 98c:	47 e0       	ldi	r20, 0x07	; 7
 98e:	50 e0       	ldi	r21, 0x00	; 0
 990:	4e 19       	sub	r20, r14
 992:	5f 09       	sbc	r21, r15
 994:	60 e0       	ldi	r22, 0x00	; 0
 996:	70 e0       	ldi	r23, 0x00	; 0
 998:	82 e0       	ldi	r24, 0x02	; 2
 99a:	90 e0       	ldi	r25, 0x00	; 0
 99c:	8c 0f       	add	r24, r28
 99e:	9d 1f       	adc	r25, r29
 9a0:	8e 0d       	add	r24, r14
 9a2:	9f 1d       	adc	r25, r15
 9a4:	d5 d1       	rcall	.+938    	; 0xd50 <memset>
           0,
           sizeof(message.as.consecutive_frame.data) - data_length);
    ret = isotp_user_send_can(link->send_arbitration_id,
 9a6:	f8 01       	movw	r30, r16
 9a8:	60 81       	ld	r22, Z
 9aa:	71 81       	ldd	r23, Z+1	; 0x01
 9ac:	82 81       	ldd	r24, Z+2	; 0x02
 9ae:	93 81       	ldd	r25, Z+3	; 0x03
 9b0:	28 e0       	ldi	r18, 0x08	; 8
 9b2:	ae 01       	movw	r20, r28
 9b4:	4f 5f       	subi	r20, 0xFF	; 255
 9b6:	5f 4f       	sbci	r21, 0xFF	; 255
 9b8:	bb dc       	rcall	.-1674   	; 0x330 <isotp_user_send_can>
#else
    ret = isotp_user_send_can(link->send_arbitration_id,
                           message.as.data_array.ptr,
                           data_length + 1);
#endif
    if (ISOTP_RET_OK == ret){
 9ba:	89 2b       	or	r24, r25
 9bc:	d1 f5       	brne	.+116    	; 0xa32 <isotp_poll+0x1a8>
        link->send_offset += data_length;
 9be:	f8 01       	movw	r30, r16
 9c0:	82 85       	ldd	r24, Z+10	; 0x0a
 9c2:	93 85       	ldd	r25, Z+11	; 0x0b
 9c4:	e8 0e       	add	r14, r24
 9c6:	f9 1e       	adc	r15, r25
 9c8:	f3 86       	std	Z+11, r15	; 0x0b
 9ca:	e2 86       	std	Z+10, r14	; 0x0a
        if (++(link->send_sn) > 0x0F){
 9cc:	84 85       	ldd	r24, Z+12	; 0x0c
 9ce:	8f 5f       	subi	r24, 0xFF	; 255
 9d0:	80 31       	cpi	r24, 0x10	; 16
 9d2:	98 f1       	brcs	.+102    	; 0xa3a <isotp_poll+0x1b0>
            link->send_sn = 0;
 9d4:	14 86       	std	Z+12, r1	; 0x0c
            /* and if st_min is zero or go beyond interval time */
            (0 == link->send_st_min || (0 != link->send_st_min && IsoTpTimeAfter(isotp_user_get_ms(), link->send_timer_st)))){
            
            ret = isotp_send_consecutive_frame(link);
            if (ISOTP_RET_OK == ret){
                if (ISOTP_INVALID_BS != link->send_bs_remain){
 9d6:	f8 01       	movw	r30, r16
 9d8:	85 85       	ldd	r24, Z+13	; 0x0d
 9da:	96 85       	ldd	r25, Z+14	; 0x0e
 9dc:	8f 3f       	cpi	r24, 0xFF	; 255
 9de:	ff ef       	ldi	r31, 0xFF	; 255
 9e0:	9f 07       	cpc	r25, r31
                    link->send_bs_remain -= 1;
 9e2:	21 f0       	breq	.+8      	; 0x9ec <isotp_poll+0x162>
 9e4:	01 97       	sbiw	r24, 0x01	; 1
 9e6:	f8 01       	movw	r30, r16
 9e8:	96 87       	std	Z+14, r25	; 0x0e
                }
                link->send_timer_bs = isotp_user_get_ms() + ISO_TP_DEFAULT_RESPONSE_TIMEOUT;
 9ea:	85 87       	std	Z+13, r24	; 0x0d
 9ec:	ba dc       	rcall	.-1676   	; 0x362 <isotp_user_get_ms>
 9ee:	dc 01       	movw	r26, r24
 9f0:	cb 01       	movw	r24, r22
 9f2:	8c 59       	subi	r24, 0x9C	; 156
 9f4:	9f 4f       	sbci	r25, 0xFF	; 255
 9f6:	af 4f       	sbci	r26, 0xFF	; 255
 9f8:	bf 4f       	sbci	r27, 0xFF	; 255
 9fa:	f8 01       	movw	r30, r16
 9fc:	85 8b       	std	Z+21, r24	; 0x15
 9fe:	96 8b       	std	Z+22, r25	; 0x16
 a00:	a7 8b       	std	Z+23, r26	; 0x17
                link->send_timer_st = isotp_user_get_ms() + link->send_st_min;
 a02:	b0 8f       	std	Z+24, r27	; 0x18
 a04:	ae dc       	rcall	.-1700   	; 0x362 <isotp_user_get_ms>
 a06:	f8 01       	movw	r30, r16
 a08:	27 85       	ldd	r18, Z+15	; 0x0f
 a0a:	dc 01       	movw	r26, r24
 a0c:	cb 01       	movw	r24, r22
 a0e:	82 0f       	add	r24, r18
 a10:	91 1d       	adc	r25, r1
 a12:	a1 1d       	adc	r26, r1
 a14:	b1 1d       	adc	r27, r1
 a16:	81 8b       	std	Z+17, r24	; 0x11
 a18:	92 8b       	std	Z+18, r25	; 0x12
 a1a:	a3 8b       	std	Z+19, r26	; 0x13
 a1c:	b4 8b       	std	Z+20, r27	; 0x14

                /* check if send finish */
                if (link->send_offset >= link->send_size){
 a1e:	22 85       	ldd	r18, Z+10	; 0x0a
 a20:	33 85       	ldd	r19, Z+11	; 0x0b
 a22:	80 85       	ldd	r24, Z+8	; 0x08
 a24:	91 85       	ldd	r25, Z+9	; 0x09
 a26:	28 17       	cp	r18, r24
 a28:	39 07       	cpc	r19, r25
 a2a:	08 f4       	brcc	.+2      	; 0xa2e <isotp_poll+0x1a4>
 a2c:	69 cf       	rjmp	.-302    	; 0x900 <isotp_poll+0x76>
                    link->send_status = ISOTP_SEND_STATUS_IDLE;
 a2e:	13 8e       	std	Z+27, r1	; 0x1b
                }
            } else {
                link->send_status = ISOTP_SEND_STATUS_ERROR;
 a30:	67 cf       	rjmp	.-306    	; 0x900 <isotp_poll+0x76>
 a32:	82 e0       	ldi	r24, 0x02	; 2
 a34:	f8 01       	movw	r30, r16
 a36:	83 8f       	std	Z+27, r24	; 0x1b
                           message.as.data_array.ptr,
                           data_length + 1);
#endif
    if (ISOTP_RET_OK == ret){
        link->send_offset += data_length;
        if (++(link->send_sn) > 0x0F){
 a38:	63 cf       	rjmp	.-314    	; 0x900 <isotp_poll+0x76>
 a3a:	f8 01       	movw	r30, r16
 a3c:	84 87       	std	Z+12, r24	; 0x0c
	IsoTpCanMessage message;
    uint8_t data_length;
    int ret;

    /* multi frame message length must greater than 7  */
    assert(link->send_size > 7);
 a3e:	cb cf       	rjmp	.-106    	; 0x9d6 <isotp_poll+0x14c>
 a40:	7a d1       	rcall	.+756    	; 0xd36 <abort>

00000a42 <__vector_5>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 a42:	1f 92       	push	r1
 a44:	0f 92       	push	r0
 a46:	0f b6       	in	r0, 0x3f	; 63
 a48:	0f 92       	push	r0
 a4a:	11 24       	eor	r1, r1
 a4c:	0b b6       	in	r0, 0x3b	; 59
 a4e:	0f 92       	push	r0
 a50:	2f 93       	push	r18
 a52:	3f 93       	push	r19
 a54:	4f 93       	push	r20
 a56:	5f 93       	push	r21
 a58:	6f 93       	push	r22
 a5a:	7f 93       	push	r23
 a5c:	8f 93       	push	r24
 a5e:	9f 93       	push	r25
 a60:	af 93       	push	r26
 a62:	bf 93       	push	r27
 a64:	ef 93       	push	r30
 a66:	ff 93       	push	r31
 a68:	ec 98       	cbi	0x1d, 4	; 29
 a6a:	2f ef       	ldi	r18, 0xFF	; 255
 a6c:	84 e3       	ldi	r24, 0x34	; 52
 a6e:	9c e0       	ldi	r25, 0x0C	; 12
 a70:	21 50       	subi	r18, 0x01	; 1
 a72:	80 40       	sbci	r24, 0x00	; 0
 a74:	90 40       	sbci	r25, 0x00	; 0
 a76:	e1 f7       	brne	.-8      	; 0xa70 <__vector_5+0x2e>
 a78:	00 c0       	rjmp	.+0      	; 0xa7a <__vector_5+0x38>
 a7a:	00 00       	nop
 a7c:	8b e0       	ldi	r24, 0x0B	; 11
 a7e:	92 e0       	ldi	r25, 0x02	; 2
 a80:	21 d1       	rcall	.+578    	; 0xcc4 <uart_puts>
 a82:	81 e0       	ldi	r24, 0x01	; 1
 a84:	80 93 a5 03 	sts	0x03A5, r24	; 0x8003a5 <run_scenario>
 a88:	ec 9a       	sbi	0x1d, 4	; 29
 a8a:	ff 91       	pop	r31
 a8c:	ef 91       	pop	r30
 a8e:	bf 91       	pop	r27
 a90:	af 91       	pop	r26
 a92:	9f 91       	pop	r25
 a94:	8f 91       	pop	r24
 a96:	7f 91       	pop	r23
 a98:	6f 91       	pop	r22
 a9a:	5f 91       	pop	r21
 a9c:	4f 91       	pop	r20
 a9e:	3f 91       	pop	r19
 aa0:	2f 91       	pop	r18
 aa2:	0f 90       	pop	r0
 aa4:	0b be       	out	0x3b, r0	; 59
 aa6:	0f 90       	pop	r0
 aa8:	0f be       	out	0x3f, r0	; 63
 aaa:	0f 90       	pop	r0
 aac:	1f 90       	pop	r1
 aae:	18 95       	reti

00000ab0 <__vector_6>:
 ab0:	1f 92       	push	r1
 ab2:	0f 92       	push	r0
 ab4:	0f b6       	in	r0, 0x3f	; 63
 ab6:	0f 92       	push	r0
 ab8:	11 24       	eor	r1, r1
 aba:	0b b6       	in	r0, 0x3b	; 59
 abc:	0f 92       	push	r0
 abe:	2f 93       	push	r18
 ac0:	3f 93       	push	r19
 ac2:	4f 93       	push	r20
 ac4:	5f 93       	push	r21
 ac6:	6f 93       	push	r22
 ac8:	7f 93       	push	r23
 aca:	8f 93       	push	r24
 acc:	9f 93       	push	r25
 ace:	af 93       	push	r26
 ad0:	bf 93       	push	r27
 ad2:	ef 93       	push	r30
 ad4:	ff 93       	push	r31
 ad6:	ed 98       	cbi	0x1d, 5	; 29
 ad8:	2f ef       	ldi	r18, 0xFF	; 255
 ada:	84 e3       	ldi	r24, 0x34	; 52
 adc:	9c e0       	ldi	r25, 0x0C	; 12
 ade:	21 50       	subi	r18, 0x01	; 1
 ae0:	80 40       	sbci	r24, 0x00	; 0
 ae2:	90 40       	sbci	r25, 0x00	; 0
 ae4:	e1 f7       	brne	.-8      	; 0xade <__vector_6+0x2e>
 ae6:	00 c0       	rjmp	.+0      	; 0xae8 <__vector_6+0x38>
 ae8:	00 00       	nop
 aea:	8e e1       	ldi	r24, 0x1E	; 30
 aec:	92 e0       	ldi	r25, 0x02	; 2
 aee:	ea d0       	rcall	.+468    	; 0xcc4 <uart_puts>
 af0:	82 e0       	ldi	r24, 0x02	; 2
 af2:	80 93 a5 03 	sts	0x03A5, r24	; 0x8003a5 <run_scenario>
 af6:	ed 9a       	sbi	0x1d, 5	; 29
 af8:	ff 91       	pop	r31
 afa:	ef 91       	pop	r30
 afc:	bf 91       	pop	r27
 afe:	af 91       	pop	r26
 b00:	9f 91       	pop	r25
 b02:	8f 91       	pop	r24
 b04:	7f 91       	pop	r23
 b06:	6f 91       	pop	r22
 b08:	5f 91       	pop	r21
 b0a:	4f 91       	pop	r20
 b0c:	3f 91       	pop	r19
 b0e:	2f 91       	pop	r18
 b10:	0f 90       	pop	r0
 b12:	0b be       	out	0x3b, r0	; 59
 b14:	0f 90       	pop	r0
 b16:	0f be       	out	0x3f, r0	; 63
 b18:	0f 90       	pop	r0
 b1a:	1f 90       	pop	r1
 b1c:	18 95       	reti

00000b1e <__vector_7>:
 b1e:	1f 92       	push	r1
 b20:	0f 92       	push	r0
 b22:	0f b6       	in	r0, 0x3f	; 63
 b24:	0f 92       	push	r0
 b26:	11 24       	eor	r1, r1
 b28:	0b b6       	in	r0, 0x3b	; 59
 b2a:	0f 92       	push	r0
 b2c:	2f 93       	push	r18
 b2e:	3f 93       	push	r19
 b30:	4f 93       	push	r20
 b32:	5f 93       	push	r21
 b34:	6f 93       	push	r22
 b36:	7f 93       	push	r23
 b38:	8f 93       	push	r24
 b3a:	9f 93       	push	r25
 b3c:	af 93       	push	r26
 b3e:	bf 93       	push	r27
 b40:	ef 93       	push	r30
 b42:	ff 93       	push	r31
 b44:	ee 98       	cbi	0x1d, 6	; 29
 b46:	2f ef       	ldi	r18, 0xFF	; 255
 b48:	84 e3       	ldi	r24, 0x34	; 52
 b4a:	9c e0       	ldi	r25, 0x0C	; 12
 b4c:	21 50       	subi	r18, 0x01	; 1
 b4e:	80 40       	sbci	r24, 0x00	; 0
 b50:	90 40       	sbci	r25, 0x00	; 0
 b52:	e1 f7       	brne	.-8      	; 0xb4c <__vector_7+0x2e>
 b54:	00 c0       	rjmp	.+0      	; 0xb56 <__vector_7+0x38>
 b56:	00 00       	nop
 b58:	81 e3       	ldi	r24, 0x31	; 49
 b5a:	92 e0       	ldi	r25, 0x02	; 2
 b5c:	b3 d0       	rcall	.+358    	; 0xcc4 <uart_puts>
 b5e:	83 e0       	ldi	r24, 0x03	; 3
 b60:	80 93 a5 03 	sts	0x03A5, r24	; 0x8003a5 <run_scenario>
 b64:	ee 9a       	sbi	0x1d, 6	; 29
 b66:	ff 91       	pop	r31
 b68:	ef 91       	pop	r30
 b6a:	bf 91       	pop	r27
 b6c:	af 91       	pop	r26
 b6e:	9f 91       	pop	r25
 b70:	8f 91       	pop	r24
 b72:	7f 91       	pop	r23
 b74:	6f 91       	pop	r22
 b76:	5f 91       	pop	r21
 b78:	4f 91       	pop	r20
 b7a:	3f 91       	pop	r19
 b7c:	2f 91       	pop	r18
 b7e:	0f 90       	pop	r0
 b80:	0b be       	out	0x3b, r0	; 59
 b82:	0f 90       	pop	r0
 b84:	0f be       	out	0x3f, r0	; 63
 b86:	0f 90       	pop	r0
 b88:	1f 90       	pop	r1
 b8a:	18 95       	reti

00000b8c <__vector_8>:
 b8c:	1f 92       	push	r1
 b8e:	0f 92       	push	r0
 b90:	0f b6       	in	r0, 0x3f	; 63
 b92:	0f 92       	push	r0
 b94:	11 24       	eor	r1, r1
 b96:	2f 93       	push	r18
 b98:	8f 93       	push	r24
 b9a:	9f 93       	push	r25
 b9c:	ef 98       	cbi	0x1d, 7	; 29
 b9e:	2f ef       	ldi	r18, 0xFF	; 255
 ba0:	84 e3       	ldi	r24, 0x34	; 52
 ba2:	9c e0       	ldi	r25, 0x0C	; 12
 ba4:	21 50       	subi	r18, 0x01	; 1
 ba6:	80 40       	sbci	r24, 0x00	; 0
 ba8:	90 40       	sbci	r25, 0x00	; 0
 baa:	e1 f7       	brne	.-8      	; 0xba4 <__vector_8+0x18>
 bac:	00 c0       	rjmp	.+0      	; 0xbae <__vector_8+0x22>
 bae:	00 00       	nop
 bb0:	ef 9a       	sbi	0x1d, 7	; 29
 bb2:	9f 91       	pop	r25
 bb4:	8f 91       	pop	r24
 bb6:	2f 91       	pop	r18
 bb8:	0f 90       	pop	r0
 bba:	0f be       	out	0x3f, r0	; 63
 bbc:	0f 90       	pop	r0
 bbe:	1f 90       	pop	r1
 bc0:	18 95       	reti

00000bc2 <main>:
static uint8_t g_isotpSendBuf[64];



 int main()
 {	
 bc2:	cf 92       	push	r12
 bc4:	df 92       	push	r13
 bc6:	ef 92       	push	r14
 bc8:	ff 92       	push	r15
 bca:	0f 93       	push	r16
 bcc:	1f 93       	push	r17
 bce:	cf 93       	push	r28
 bd0:	df 93       	push	r29
 bd2:	cd b7       	in	r28, 0x3d	; 61
 bd4:	de b7       	in	r29, 0x3e	; 62
 bd6:	a5 97       	sbiw	r28, 0x25	; 37
 bd8:	0f b6       	in	r0, 0x3f	; 63
 bda:	f8 94       	cli
 bdc:	de bf       	out	0x3e, r29	; 62
 bde:	0f be       	out	0x3f, r0	; 63
 be0:	cd bf       	out	0x3d, r28	; 61
	 uart_init();
 be2:	64 d0       	rcall	.+200    	; 0xcac <uart_init>
} run_t;

volatile run_t run_scenario = NOTHING;
		
void buttons_init(){
	DDRE = 0x00;
 be4:	1d b8       	out	0x0d, r1	; 13
	PORTE = 1 << PE4 | 1 << PE5 | 1 << PE6 | 1 << PE7;
 be6:	80 ef       	ldi	r24, 0xF0	; 240
 be8:	8e b9       	out	0x0e, r24	; 14
	EICRB = 0x00;
 bea:	10 92 6a 00 	sts	0x006A, r1	; 0x80006a <__TEXT_REGION_LENGTH__+0x7e006a>

 int main()
 {	
	 uart_init();
	 buttons_init();
	 can_init();
 bee:	8d bb       	out	0x1d, r24	; 29
 bf0:	6f da       	rcall	.-2850   	; 0xd0 <can_init>
	 uart_puts("test");
 bf2:	87 ee       	ldi	r24, 0xE7	; 231
 bf4:	92 e0       	ldi	r25, 0x02	; 2
	 clock_Init();
 bf6:	66 d0       	rcall	.+204    	; 0xcc4 <uart_puts>
 bf8:	92 db       	rcall	.-2268   	; 0x31e <clock_Init>
	 
	 isotp_init_link(&g_link, 0x00,
 bfa:	80 e4       	ldi	r24, 0x40	; 64
 bfc:	c8 2e       	mov	r12, r24
 bfe:	d1 2c       	mov	r13, r1
 c00:	94 e3       	ldi	r25, 0x34	; 52
 c02:	e9 2e       	mov	r14, r25
 c04:	93 e0       	ldi	r25, 0x03	; 3
 c06:	f9 2e       	mov	r15, r25
 c08:	00 e4       	ldi	r16, 0x40	; 64
 c0a:	10 e0       	ldi	r17, 0x00	; 0
 c0c:	24 ef       	ldi	r18, 0xF4	; 244
 c0e:	32 e0       	ldi	r19, 0x02	; 2
 c10:	40 e0       	ldi	r20, 0x00	; 0
 c12:	50 e0       	ldi	r21, 0x00	; 0
 c14:	ba 01       	movw	r22, r20
 c16:	84 e7       	ldi	r24, 0x74	; 116
 c18:	93 e0       	ldi	r25, 0x03	; 3
 c1a:	16 de       	rcall	.-980    	; 0x848 <isotp_init_link>
					g_isotpSendBuf, sizeof(g_isotpSendBuf), 
					g_isotpRecvBuf, sizeof(g_isotpRecvBuf));
    
    while(1){
		uint8_t ret;
		uint8_t payload[28] = {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};
 c1c:	be 01       	movw	r22, r28
 c1e:	6f 5f       	subi	r22, 0xFF	; 255
 c20:	7f 4f       	sbci	r23, 0xFF	; 255
 c22:	8c e1       	ldi	r24, 0x1C	; 28
 c24:	fb 01       	movw	r30, r22
 c26:	11 92       	st	Z+, r1
 c28:	8a 95       	dec	r24
 c2a:	e9 f7       	brne	.-6      	; 0xc26 <main+0x64>
 c2c:	81 e0       	ldi	r24, 0x01	; 1
 c2e:	89 83       	std	Y+1, r24	; 0x01
		
        
        /* And send message with isotp_send */
        ret = isotp_send(&g_link, payload, 28);
 c30:	8c 8f       	std	Y+28, r24	; 0x1c
 c32:	4c e1       	ldi	r20, 0x1C	; 28
 c34:	50 e0       	ldi	r21, 0x00	; 0
 c36:	84 e7       	ldi	r24, 0x74	; 116
 c38:	93 e0       	ldi	r25, 0x03	; 3
 c3a:	75 dc       	rcall	.-1814   	; 0x526 <isotp_send>
        } else {
            /* Error occur */
        }
		can_msg_t message;
		uint8_t len;
		while(g_link.send_status == ISOTP_SEND_STATUS_INPROGRESS){
 c3c:	80 91 8f 03 	lds	r24, 0x038F	; 0x80038f <g_link+0x1b>
 c40:	81 30       	cpi	r24, 0x01	; 1
 c42:	19 f5       	brne	.+70     	; 0xc8a <main+0xc8>
			can_receive_message(0,default_id,zero_mask,message,&len);
 c44:	8e 01       	movw	r16, r28
 c46:	0b 5d       	subi	r16, 0xDB	; 219
 c48:	1f 4f       	sbci	r17, 0xFF	; 255
 c4a:	9e 01       	movw	r18, r28
 c4c:	23 5e       	subi	r18, 0xE3	; 227
 c4e:	3f 4f       	sbci	r19, 0xFF	; 255
 c50:	4c ee       	ldi	r20, 0xEC	; 236
 c52:	52 e0       	ldi	r21, 0x02	; 2
 c54:	6e ee       	ldi	r22, 0xEE	; 238
 c56:	72 e0       	ldi	r23, 0x02	; 2
 c58:	80 e0       	ldi	r24, 0x00	; 0
 c5a:	ba da       	rcall	.-2700   	; 0x1d0 <can_receive_message>
			isotp_on_can_message(&g_link,message,len);
 c5c:	4d a1       	ldd	r20, Y+37	; 0x25
 c5e:	be 01       	movw	r22, r28
 c60:	63 5e       	subi	r22, 0xE3	; 227
 c62:	7f 4f       	sbci	r23, 0xFF	; 255
 c64:	84 e7       	ldi	r24, 0x74	; 116
 c66:	93 e0       	ldi	r25, 0x03	; 3
 c68:	6b dc       	rcall	.-1834   	; 0x540 <isotp_on_can_message>
 c6a:	ff ef       	ldi	r31, 0xFF	; 255
 c6c:	21 ee       	ldi	r18, 0xE1	; 225
 c6e:	84 e0       	ldi	r24, 0x04	; 4
 c70:	f1 50       	subi	r31, 0x01	; 1
 c72:	20 40       	sbci	r18, 0x00	; 0
 c74:	80 40       	sbci	r24, 0x00	; 0
 c76:	e1 f7       	brne	.-8      	; 0xc70 <main+0xae>
 c78:	00 c0       	rjmp	.+0      	; 0xc7a <main+0xb8>
 c7a:	00 00       	nop
			_delay_ms(200);
			isotp_poll(&g_link);	
 c7c:	84 e7       	ldi	r24, 0x74	; 116
 c7e:	93 e0       	ldi	r25, 0x03	; 3
 c80:	04 de       	rcall	.-1016   	; 0x88a <isotp_poll>
 c82:	80 91 8f 03 	lds	r24, 0x038F	; 0x80038f <g_link+0x1b>
        } else {
            /* Error occur */
        }
		can_msg_t message;
		uint8_t len;
		while(g_link.send_status == ISOTP_SEND_STATUS_INPROGRESS){
 c86:	81 30       	cpi	r24, 0x01	; 1
 c88:	e9 f2       	breq	.-70     	; 0xc44 <main+0x82>
 c8a:	8d a1       	ldd	r24, Y+37	; 0x25
			can_receive_message(0,default_id,zero_mask,message,&len);
			isotp_on_can_message(&g_link,message,len);
			_delay_ms(200);
			isotp_poll(&g_link);	
		}
		return len;
 c8c:	90 e0       	ldi	r25, 0x00	; 0
 c8e:	a5 96       	adiw	r28, 0x25	; 37
				break;
		}
	 }
	 return 0;
	 */
 }
 c90:	0f b6       	in	r0, 0x3f	; 63
 c92:	f8 94       	cli
 c94:	de bf       	out	0x3e, r29	; 62
 c96:	0f be       	out	0x3f, r0	; 63
 c98:	cd bf       	out	0x3d, r28	; 61
 c9a:	df 91       	pop	r29
 c9c:	cf 91       	pop	r28
 c9e:	1f 91       	pop	r17
 ca0:	0f 91       	pop	r16
 ca2:	ff 90       	pop	r15
 ca4:	ef 90       	pop	r14
 ca6:	df 90       	pop	r13
 ca8:	cf 90       	pop	r12
 caa:	08 95       	ret

00000cac <uart_init>:
#include "uart_f.h"
#include "types.h"


void uart_init(){
	UBRR0H = (BAUD_PRESCALE >> 8); // Load upper 8-bits of the baud rate value into the high byte of the UBRR register
 cac:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
	UBRR0L = BAUD_PRESCALE; // Load lower 8-bits of the baud rate value into the low byte of the UBRR register
 cb0:	83 e3       	ldi	r24, 0x33	; 51
 cb2:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	UCSR0C = (0<<UMSEL0) | (0<<UPM0) | (1<<USBS0) | (3<<UCSZ0);
 cb6:	8e e0       	ldi	r24, 0x0E	; 14
 cb8:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
	UCSR0B = (1<<RXEN0) | (1<<TXEN0);
 cbc:	88 e1       	ldi	r24, 0x18	; 24
 cbe:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
 cc2:	08 95       	ret

00000cc4 <uart_puts>:
}

void uart_puts(char* s){
 cc4:	cf 93       	push	r28
 cc6:	df 93       	push	r29
 cc8:	1f 92       	push	r1
 cca:	cd b7       	in	r28, 0x3d	; 61
 ccc:	de b7       	in	r29, 0x3e	; 62
 cce:	dc 01       	movw	r26, r24
	volatile uint8_t i;
	int len = strlen(s);
 cd0:	fc 01       	movw	r30, r24
 cd2:	01 90       	ld	r0, Z+
 cd4:	00 20       	and	r0, r0
 cd6:	e9 f7       	brne	.-6      	; 0xcd2 <uart_puts+0xe>
 cd8:	31 97       	sbiw	r30, 0x01	; 1
 cda:	af 01       	movw	r20, r30
 cdc:	48 1b       	sub	r20, r24
 cde:	59 0b       	sbc	r21, r25
	for (i = 0; i < len; i++){
 ce0:	19 82       	std	Y+1, r1	; 0x01
 ce2:	89 81       	ldd	r24, Y+1	; 0x01
 ce4:	90 e0       	ldi	r25, 0x00	; 0
 ce6:	84 17       	cp	r24, r20
 ce8:	95 07       	cpc	r25, r21
 cea:	9c f4       	brge	.+38     	; 0xd12 <uart_puts+0x4e>
		while(!( UCSR0A & 0X20));
 cec:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 cf0:	95 ff       	sbrs	r25, 5
 cf2:	fc cf       	rjmp	.-8      	; 0xcec <uart_puts+0x28>
		UDR0=s[i];
 cf4:	99 81       	ldd	r25, Y+1	; 0x01
 cf6:	fd 01       	movw	r30, r26
 cf8:	e9 0f       	add	r30, r25
 cfa:	f1 1d       	adc	r31, r1
 cfc:	90 81       	ld	r25, Z
 cfe:	90 93 c6 00 	sts	0x00C6, r25	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
}

void uart_puts(char* s){
	volatile uint8_t i;
	int len = strlen(s);
	for (i = 0; i < len; i++){
 d02:	99 81       	ldd	r25, Y+1	; 0x01
 d04:	9f 5f       	subi	r25, 0xFF	; 255
 d06:	99 83       	std	Y+1, r25	; 0x01
 d08:	29 81       	ldd	r18, Y+1	; 0x01
 d0a:	30 e0       	ldi	r19, 0x00	; 0
 d0c:	24 17       	cp	r18, r20
 d0e:	35 07       	cpc	r19, r21
 d10:	6c f3       	brlt	.-38     	; 0xcec <uart_puts+0x28>
		while(!( UCSR0A & 0X20));
		UDR0=s[i];
	}
	while(!( UCSR0A & 0X20));
 d12:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 d16:	85 ff       	sbrs	r24, 5
 d18:	fc cf       	rjmp	.-8      	; 0xd12 <uart_puts+0x4e>
	UDR0 = 13;
 d1a:	8d e0       	ldi	r24, 0x0D	; 13
 d1c:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	while(!( UCSR0A & 0X20));
 d20:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 d24:	85 ff       	sbrs	r24, 5
 d26:	fc cf       	rjmp	.-8      	; 0xd20 <uart_puts+0x5c>
	UDR0 = 10;
 d28:	8a e0       	ldi	r24, 0x0A	; 10
 d2a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
}
 d2e:	0f 90       	pop	r0
 d30:	df 91       	pop	r29
 d32:	cf 91       	pop	r28
 d34:	08 95       	ret

00000d36 <abort>:
 d36:	81 e0       	ldi	r24, 0x01	; 1
 d38:	90 e0       	ldi	r25, 0x00	; 0
 d3a:	f8 94       	cli
 d3c:	10 c0       	rjmp	.+32     	; 0xd5e <_exit>

00000d3e <memcpy>:
 d3e:	fb 01       	movw	r30, r22
 d40:	dc 01       	movw	r26, r24
 d42:	02 c0       	rjmp	.+4      	; 0xd48 <memcpy+0xa>
 d44:	01 90       	ld	r0, Z+
 d46:	0d 92       	st	X+, r0
 d48:	41 50       	subi	r20, 0x01	; 1
 d4a:	50 40       	sbci	r21, 0x00	; 0
 d4c:	d8 f7       	brcc	.-10     	; 0xd44 <memcpy+0x6>
 d4e:	08 95       	ret

00000d50 <memset>:
 d50:	dc 01       	movw	r26, r24
 d52:	01 c0       	rjmp	.+2      	; 0xd56 <memset+0x6>
 d54:	6d 93       	st	X+, r22
 d56:	41 50       	subi	r20, 0x01	; 1
 d58:	50 40       	sbci	r21, 0x00	; 0
 d5a:	e0 f7       	brcc	.-8      	; 0xd54 <memset+0x4>
 d5c:	08 95       	ret

00000d5e <_exit>:
 d5e:	f8 94       	cli

00000d60 <__stop_program>:
 d60:	ff cf       	rjmp	.-2      	; 0xd60 <__stop_program>
