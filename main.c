// This is a RSA implementation for the Mega or AVR4 core that is a at90s8515 
// By Emile van der Laan.
// This is not free ware, but if you use this commercially you will need to give a at least 100 Euro and 0.10 euro per device to a GNU project.
// It uses AVR Studio 4.12.452,and WINAVR 
// And WinAVR - 20050214

// 1520 Bytes of Flash used for both the decrypt and encrypt 
// 202 msec on a at90s8515 @ 8 Mc and 512 Bits and exponent of 3 
// 174 msec on a ATMEGA32  @ 8 Mc and 512 Bits and exponent of 3
// 76.6 sec on a at90s8515 @ 8 Mc and 512 Bits and exponent of 512 bits
// 65.4 sec on a ATMEGA32  @ 8 Mc and 512 Bits exponent of 512 bits
#include "rsa.h"

#include "rsa_asm.h"
#include <avr\pgmspace.h>
#include <string.h>

unsigned char PROGMEM const private_key_flash[RSALEN]=
{ 
	0x26,0x49,0x42,0x16,0xcc,0x84,0xbd,0x54,0xf5,0x0e,0xc7,0x4f,0x03,0xd4,0xd6,0xb8,0x76,0x0f,0x63,0xcc,0xc0,0x98,0x32,0xff,0x13,0xa6,0xdd,0x51,0xe9,0x2c,0xe5,0x2b,
	0x04,0xf3,0xb2,0xa4,0xce,0xf5,0xd8,0x7f,0xff,0x52,0x13,0x49,0xaf,0x4e,0xc3,0x7d,0x76,0xec,0x6b,0x44,0xd0,0xc2,0x65,0x8c,0xe1,0x93,0x4f,0x7c,0x30,0x9e,0x01,0x23 
};

unsigned char PROGMEM const public_key_flash[RSALEN]=
{
	0xe5,0xb7,0x8c,0x88,0xcb,0x1c,0x6f,0xfd,0xbe,0x58,0xab,0xda,0x16,0xfd,0x08,0x52,0xc4,0x5c,0x56,0xcc,0x83,0x91,0x31,0xfa,0x75,0xe9,0x2f,0xeb,0x77,0x0d,0x5f,0x04,
	0x03,0x23,0x55,0x07,0xf4,0x59,0x76,0xe7,0x7b,0x1c,0xd6,0x48,0x90,0xfb,0xc0,0x90,0x12,0x1b,0xf4,0x14,0xfd,0xfa,0x7c,0x22,0xc5,0x46,0x58,0xf5,0x2c,0x97,0xf1,0x0f 
};


/* just random data for testeting */
unsigned char PROGMEM const CONSTANT_DATA[RSALEN]=
{
	0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x5A,0x59,0xE9,0x71,0x1A,0xCB,0x01,0x11,0xDF,0x92,0x8E,0xF4,0x7B,0xAD,0xD8,0x69,
	0xD5,0x8F,0x8C,0xAD,0xC2,0xEB,0xAD,0xCC,0x01,0xB9,0xB2,0x36,0x42,0xF4,0xA0,0x3A,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0x00,0xff
};

/* This is the encrypted data for testeting */
unsigned char PROGMEM const CRYPYT_DATA[RSALEN]=
{
	0x79,0x3f,0x5D,0x9c,0xD2,0xD6,0x57,0x82,0xAE,0xBB,0x1E,0x9A,0x12,0x53,0xCC,0x4F,0xDD,0x12,0xF1,0x40,0xEB,0xD2,0xF3,0x47,0xB3,0x30,0x13,0xF8,0x01,0xFF,0x12,0x8F,
	0x53,0x18,0xEE,0x7A,0xD7,0xFE,0xB2,0xEA,0x04,0xFA,0x8C,0xD3,0xD8,0xEF,0xAB,0x49,0x7B,0xC5,0x6C,0xCE,0x03,0x5D,0xC8,0x44,0x84,0xE3,0x01,0x4C,0xA0,0xBD,0x07,0x87
};


unsigned char cryptdata[RSALEN];
unsigned char public_key[RSALEN];
unsigned char private_key[RSALEN];

unsigned char public_exponent;

int main(void )
{
unsigned char f;

/* (plaintext^private_key)%public_key = ciphertext */

	for(f=0;f<sizeof(cryptdata);f++) cryptdata[f]=pgm_read_byte_near(&CONSTANT_DATA[f]);
	for(f=0;f<sizeof(public_key);f++) public_key[f]=pgm_read_byte_near(&public_key_flash[f]);
	for(f=0;f<sizeof(private_key);f++) private_key[f]=pgm_read_byte_near(&private_key_flash[f]);

	rsa_inc(cryptdata ,private_key,public_key);

	for(f=0;f<64;f++) cryptdata[f]=pgm_read_byte_near(&CRYPYT_DATA[f]);

/* (ciphertext^public_exponent)%public_key =  plaintext */
 	public_exponent=3;
 	for(f=0;f<64;f++) public_key[f]=pgm_read_byte_near(&public_key_flash[f]);

	rsa(cryptdata,public_exponent,public_key); 

	return 0;
}
